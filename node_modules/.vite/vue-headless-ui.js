import {
  setupDevtoolsPlugin
} from "./chunk-BWA42NZA.js";
import "./chunk-YMDEUY5V.js";
import {
  Fragment,
  Teleport,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  mergeProps,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vModelText,
  warn,
  watch,
  watchEffect,
  withCtx,
  withDirectives
} from "./chunk-UZSTWDUF.js";
import {
  computed,
  isRef,
  markRaw,
  normalizeStyle,
  reactive,
  readonly,
  ref,
  toDisplayString,
  toRef,
  unref
} from "./chunk-3P2FRRWU.js";
import "./chunk-VP3FZ6LR.js";

// node_modules/vee-validate/dist/vee-validate.esm.js
function isCallable(fn) {
  return typeof fn === "function";
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
var isObject = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
function isIndex(value) {
  return Number(value) >= 0;
}
function toNumber(value) {
  const n = parseFloat(value);
  return isNaN(n) ? value : n;
}
var RULES = {};
function resolveRule(id) {
  return RULES[id];
}
var FormContextKey = Symbol("vee-validate-form");
var FieldContextKey = Symbol("vee-validate-field-instance");
var IS_ABSENT = Symbol("Default empty value");
function isLocator(value) {
  return isCallable(value) && !!value.__locatorRef;
}
function isHTMLTag(tag) {
  return ["input", "textarea", "select"].includes(tag);
}
function isFileInputNode(tag, attrs) {
  return isHTMLTag(tag) && attrs.type === "file";
}
function isYupValidator(value) {
  return !!value && isCallable(value.validate);
}
function hasCheckedAttr(type) {
  return type === "checkbox" || type === "radio";
}
function isContainerValue(value) {
  return isObject(value) || Array.isArray(value);
}
function isEmptyContainer(value) {
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return isObject(value) && Object.keys(value).length === 0;
}
function isNotNestedPath(path) {
  return /^\[.+\]$/i.test(path);
}
function isNativeMultiSelect(el) {
  return isNativeSelect(el) && el.multiple;
}
function isNativeSelect(el) {
  return el.tagName === "SELECT";
}
function isNativeMultiSelectNode(tag, attrs) {
  const hasTruthyBindingValue = ![false, null, void 0, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);
  return tag === "select" && "multiple" in attrs && hasTruthyBindingValue;
}
function shouldHaveValueBinding(tag, attrs) {
  return isNativeMultiSelectNode(tag, attrs) || isFileInputNode(tag, attrs);
}
function isFormSubmitEvent(evt) {
  return isEvent(evt) && evt.target && "submit" in evt.target;
}
function isEvent(evt) {
  if (!evt) {
    return false;
  }
  if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
    return true;
  }
  if (evt && evt.srcElement) {
    return true;
  }
  return false;
}
function isPropPresent(obj, prop) {
  return prop in obj && obj[prop] !== IS_ABSENT;
}
function cleanupNonNestedPath(path) {
  if (isNotNestedPath(path)) {
    return path.replace(/\[|\]/gi, "");
  }
  return path;
}
function getFromPath(object, path, fallback) {
  if (!object) {
    return fallback;
  }
  if (isNotNestedPath(path)) {
    return object[cleanupNonNestedPath(path)];
  }
  const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
    if (isContainerValue(acc) && propKey in acc) {
      return acc[propKey];
    }
    return fallback;
  }, object);
  return resolvedValue;
}
function setInPath(object, path, value) {
  if (isNotNestedPath(path)) {
    object[cleanupNonNestedPath(path)] = value;
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i = 0; i < keys.length; i++) {
    if (i === keys.length - 1) {
      acc[keys[i]] = value;
      return;
    }
    if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {
      acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};
    }
    acc = acc[keys[i]];
  }
}
function unset(object, key) {
  if (Array.isArray(object) && isIndex(key)) {
    object.splice(Number(key), 1);
    return;
  }
  if (isObject(object)) {
    delete object[key];
  }
}
function unsetPath(object, path) {
  if (isNotNestedPath(path)) {
    delete object[cleanupNonNestedPath(path)];
    return;
  }
  const keys = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i = 0; i < keys.length; i++) {
    if (i === keys.length - 1) {
      unset(acc, keys[i]);
      break;
    }
    if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {
      break;
    }
    acc = acc[keys[i]];
  }
  const pathValues = keys.map((_, idx) => {
    return getFromPath(object, keys.slice(0, idx).join("."));
  });
  for (let i = pathValues.length - 1; i >= 0; i--) {
    if (!isEmptyContainer(pathValues[i])) {
      continue;
    }
    if (i === 0) {
      unset(object, keys[0]);
      continue;
    }
    unset(pathValues[i - 1], keys[i - 1]);
  }
}
function keysOf(record) {
  return Object.keys(record);
}
function injectWithSelf(symbol, def = void 0) {
  const vm = getCurrentInstance();
  return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);
}
function warn2(message) {
  warn(`[vee-validate]: ${message}`);
}
function normalizeField(field) {
  if (Array.isArray(field)) {
    return field[0];
  }
  return field;
}
function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
  if (Array.isArray(currentValue)) {
    const newVal = [...currentValue];
    const idx = newVal.indexOf(checkedValue);
    idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
    return newVal;
  }
  return currentValue === checkedValue ? uncheckedValue : checkedValue;
}
function throttle(func, limit) {
  let inThrottle;
  let lastResult;
  return function(...args) {
    const context = this;
    if (!inThrottle) {
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
      lastResult = func.apply(context, args);
    }
    return lastResult;
  };
}
function debounceAsync(inner, ms = 0) {
  let timer = null;
  let resolves = [];
  return function(...args) {
    if (timer) {
      window.clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      const result = inner(...args);
      resolves.forEach((r) => r(result));
      resolves = [];
    }, ms);
    return new Promise((resolve) => resolves.push(resolve));
  };
}
var normalizeChildren = (tag, context, slotProps) => {
  if (!context.slots.default) {
    return context.slots.default;
  }
  if (typeof tag === "string" || !tag) {
    return context.slots.default(slotProps());
  }
  return {
    default: () => {
      var _a, _b;
      return (_b = (_a = context.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps());
    }
  };
};
function getBoundValue(el) {
  if (hasValueBinding(el)) {
    return el._value;
  }
  return void 0;
}
function hasValueBinding(el) {
  return "_value" in el;
}
function normalizeEventValue(value) {
  if (!isEvent(value)) {
    return value;
  }
  const input = value.target;
  if (hasCheckedAttr(input.type) && hasValueBinding(input)) {
    return getBoundValue(input);
  }
  if (input.type === "file" && input.files) {
    return Array.from(input.files);
  }
  if (isNativeMultiSelect(input)) {
    return Array.from(input.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
  }
  if (isNativeSelect(input)) {
    const selectedOption = Array.from(input.options).find((opt) => opt.selected);
    return selectedOption ? getBoundValue(selectedOption) : input.value;
  }
  return input.value;
}
function normalizeRules(rules) {
  const acc = {};
  Object.defineProperty(acc, "_$$isNormalized", {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
  if (!rules) {
    return acc;
  }
  if (isObject(rules) && rules._$$isNormalized) {
    return rules;
  }
  if (isObject(rules)) {
    return Object.keys(rules).reduce((prev, curr) => {
      const params = normalizeParams(rules[curr]);
      if (rules[curr] !== false) {
        prev[curr] = buildParams(params);
      }
      return prev;
    }, acc);
  }
  if (typeof rules !== "string") {
    return acc;
  }
  return rules.split("|").reduce((prev, rule) => {
    const parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev;
    }
    prev[parsedRule.name] = buildParams(parsedRule.params);
    return prev;
  }, acc);
}
function normalizeParams(params) {
  if (params === true) {
    return [];
  }
  if (Array.isArray(params)) {
    return params;
  }
  if (isObject(params)) {
    return params;
  }
  return [params];
}
function buildParams(provided) {
  const mapValueToLocator = (value) => {
    if (typeof value === "string" && value[0] === "@") {
      return createLocator(value.slice(1));
    }
    return value;
  };
  if (Array.isArray(provided)) {
    return provided.map(mapValueToLocator);
  }
  if (provided instanceof RegExp) {
    return [provided];
  }
  return Object.keys(provided).reduce((prev, key) => {
    prev[key] = mapValueToLocator(provided[key]);
    return prev;
  }, {});
}
var parseRule = (rule) => {
  let params = [];
  const name = rule.split(":")[0];
  if (rule.includes(":")) {
    params = rule.split(":").slice(1).join(":").split(",");
  }
  return { name, params };
};
function createLocator(value) {
  const locator = (crossTable) => {
    const val = getFromPath(crossTable, value) || crossTable[value];
    return val;
  };
  locator.__locatorRef = value;
  return locator;
}
function extractLocators(params) {
  if (Array.isArray(params)) {
    return params.filter(isLocator);
  }
  return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
}
var DEFAULT_CONFIG = {
  generateMessage: ({ field }) => `${field} is not valid.`,
  bails: true,
  validateOnBlur: true,
  validateOnChange: true,
  validateOnInput: false,
  validateOnModelUpdate: true
};
var currentConfig = Object.assign({}, DEFAULT_CONFIG);
var getConfig = () => currentConfig;
async function validate(value, rules, options = {}) {
  const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
  const field = {
    name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
    rules,
    bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
    formData: (options === null || options === void 0 ? void 0 : options.values) || {}
  };
  const result = await _validate(field, value);
  const errors = result.errors;
  return {
    errors,
    valid: !errors.length
  };
}
async function _validate(field, value) {
  if (isYupValidator(field.rules)) {
    return validateFieldWithYup(value, field.rules, { bails: field.bails });
  }
  if (isCallable(field.rules)) {
    const ctx = {
      field: field.name,
      form: field.formData,
      value
    };
    const result = await field.rules(value, ctx);
    const isValid = typeof result !== "string" && result;
    const message = typeof result === "string" ? result : _generateFieldError(ctx);
    return {
      errors: !isValid ? [message] : []
    };
  }
  const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });
  const errors = [];
  const rulesKeys = Object.keys(normalizedContext.rules);
  const length = rulesKeys.length;
  for (let i = 0; i < length; i++) {
    const rule = rulesKeys[i];
    const result = await _test(normalizedContext, value, {
      name: rule,
      params: normalizedContext.rules[rule]
    });
    if (result.error) {
      errors.push(result.error);
      if (field.bails) {
        return {
          errors
        };
      }
    }
  }
  return {
    errors
  };
}
async function validateFieldWithYup(value, validator, opts) {
  var _a;
  const errors = await validator.validate(value, {
    abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true
  }).then(() => []).catch((err) => {
    if (err.name === "ValidationError") {
      return err.errors;
    }
    throw err;
  });
  return {
    errors
  };
}
async function _test(field, value, rule) {
  const validator = resolveRule(rule.name);
  if (!validator) {
    throw new Error(`No such validator '${rule.name}' exists.`);
  }
  const params = fillTargetValues(rule.params, field.formData);
  const ctx = {
    field: field.name,
    value,
    form: field.formData,
    rule: Object.assign(Object.assign({}, rule), { params })
  };
  const result = await validator(value, params, ctx);
  if (typeof result === "string") {
    return {
      error: result
    };
  }
  return {
    error: result ? void 0 : _generateFieldError(ctx)
  };
}
function _generateFieldError(fieldCtx) {
  const message = getConfig().generateMessage;
  if (!message) {
    return "Field is invalid";
  }
  return message(fieldCtx);
}
function fillTargetValues(params, crossTable) {
  const normalize = (value) => {
    if (isLocator(value)) {
      return value(crossTable);
    }
    return value;
  };
  if (Array.isArray(params)) {
    return params.map(normalize);
  }
  return Object.keys(params).reduce((acc, param) => {
    acc[param] = normalize(params[param]);
    return acc;
  }, {});
}
async function validateYupSchema(schema, values) {
  const errorObjects = await schema.validate(values, { abortEarly: false }).then(() => []).catch((err) => {
    if (err.name !== "ValidationError") {
      throw err;
    }
    return err.inner || [];
  });
  const results = {};
  const errors = {};
  for (const error of errorObjects) {
    const messages = error.errors;
    results[error.path] = { valid: !messages.length, errors: messages };
    if (messages.length) {
      errors[error.path] = messages[0];
    }
  }
  return {
    valid: !errorObjects.length,
    results,
    errors
  };
}
async function validateObjectSchema(schema, values, opts) {
  const paths = keysOf(schema);
  const validations = paths.map(async (path) => {
    var _a, _b, _c;
    const fieldResult = await validate(getFromPath(values, path), schema[path], {
      name: ((_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path]) || path,
      values,
      bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
    });
    return Object.assign(Object.assign({}, fieldResult), { path });
  });
  let isAllValid = true;
  const validationResults = await Promise.all(validations);
  const results = {};
  const errors = {};
  for (const result of validationResults) {
    results[result.path] = {
      valid: result.valid,
      errors: result.errors
    };
    if (!result.valid) {
      isAllValid = false;
      errors[result.path] = result.errors[0];
    }
  }
  return {
    valid: isAllValid,
    results,
    errors
  };
}
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k])
        continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
var es6 = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      for (i of a.entries())
        if (!equal(i[1], b.get(i[0])))
          return false;
      return true;
    }
    if (a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (a[i] !== b[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var ID_COUNTER = 0;
function useFieldState(path, init) {
  const { value, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, !init.standalone);
  const { errorMessage, errors, setErrors } = _useFieldErrors(path, !init.standalone);
  const meta = _useFieldMeta(value, initialValue, errors);
  const id = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
  function setState(state) {
    var _a;
    if ("value" in state) {
      value.value = state.value;
    }
    if ("errors" in state) {
      setErrors(state.errors);
    }
    if ("touched" in state) {
      meta.touched = (_a = state.touched) !== null && _a !== void 0 ? _a : meta.touched;
    }
    if ("initialValue" in state) {
      setInitialValue(state.initialValue);
    }
  }
  return {
    id,
    path,
    value,
    initialValue,
    meta,
    errors,
    errorMessage,
    setState
  };
}
function _useFieldValue(path, modelValue, shouldInjectForm) {
  const form = shouldInjectForm ? injectWithSelf(FormContextKey, void 0) : void 0;
  const modelRef = ref(unref(modelValue));
  function resolveInitialValue2() {
    if (!form) {
      return unref(modelRef);
    }
    return getFromPath(form.meta.value.initialValues, unref(path), unref(modelRef));
  }
  function setInitialValue(value2) {
    if (!form) {
      modelRef.value = value2;
      return;
    }
    form.setFieldInitialValue(unref(path), value2);
  }
  const initialValue = computed(resolveInitialValue2);
  if (!form) {
    const value2 = ref(resolveInitialValue2());
    return {
      value: value2,
      initialValue,
      setInitialValue
    };
  }
  const currentValue = modelValue ? unref(modelValue) : getFromPath(form.values, unref(path), unref(initialValue));
  form.stageInitialValue(unref(path), currentValue);
  const value = computed({
    get() {
      return getFromPath(form.values, unref(path));
    },
    set(newVal) {
      form.setFieldValue(unref(path), newVal);
    }
  });
  return {
    value,
    initialValue,
    setInitialValue
  };
}
function _useFieldMeta(currentValue, initialValue, errors) {
  const meta = reactive({
    touched: false,
    pending: false,
    valid: true,
    validated: !!unref(errors).length,
    initialValue: computed(() => unref(initialValue)),
    dirty: computed(() => {
      return !es6(unref(currentValue), unref(initialValue));
    })
  });
  watch(errors, (value) => {
    meta.valid = !value.length;
  }, {
    immediate: true,
    flush: "sync"
  });
  return meta;
}
function _useFieldErrors(path, shouldInjectForm) {
  const form = shouldInjectForm ? injectWithSelf(FormContextKey, void 0) : void 0;
  function normalizeErrors(messages) {
    if (!messages) {
      return [];
    }
    return Array.isArray(messages) ? messages : [messages];
  }
  if (!form) {
    const errors2 = ref([]);
    return {
      errors: errors2,
      errorMessage: computed(() => errors2.value[0]),
      setErrors: (messages) => {
        errors2.value = normalizeErrors(messages);
      }
    };
  }
  const errors = computed(() => form.errorBag.value[unref(path)] || []);
  return {
    errors,
    errorMessage: computed(() => errors.value[0]),
    setErrors: (messages) => {
      form.setFieldErrorBag(unref(path), normalizeErrors(messages));
    }
  };
}
function installDevtoolsPlugin(app) {
  if (true) {
    setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, setupApiHooks);
  }
}
var DEVTOOLS_FORMS = {};
var DEVTOOLS_FIELDS = {};
var API;
var refreshInspector = throttle(() => {
  setTimeout(async () => {
    await nextTick();
    API === null || API === void 0 ? void 0 : API.sendInspectorState(INSPECTOR_ID);
    API === null || API === void 0 ? void 0 : API.sendInspectorTree(INSPECTOR_ID);
  }, 100);
}, 100);
function registerFormWithDevTools(form) {
  const vm = getCurrentInstance();
  if (!API) {
    const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
    if (!app) {
      return;
    }
    installDevtoolsPlugin(app);
  }
  DEVTOOLS_FORMS[form.formId] = Object.assign({}, form);
  DEVTOOLS_FORMS[form.formId]._vm = vm;
  onUnmounted(() => {
    delete DEVTOOLS_FORMS[form.formId];
    refreshInspector();
  });
  refreshInspector();
}
function registerSingleFieldWithDevtools(field) {
  const vm = getCurrentInstance();
  if (!API) {
    const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
    if (!app) {
      return;
    }
    installDevtoolsPlugin(app);
  }
  DEVTOOLS_FIELDS[field.id] = Object.assign({}, field);
  DEVTOOLS_FIELDS[field.id]._vm = vm;
  onUnmounted(() => {
    delete DEVTOOLS_FIELDS[field.id];
    refreshInspector();
  });
  refreshInspector();
}
var INSPECTOR_ID = "vee-validate-inspector";
var COLORS = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
var SELECTED_NODE = null;
function setupApiHooks(api) {
  API = api;
  api.addInspector({
    id: INSPECTOR_ID,
    icon: "rule",
    label: "vee-validate",
    noSelectionText: "Select a vee-validate node to inspect",
    actions: [
      {
        icon: "done_outline",
        tooltip: "Validate selected item",
        action: async () => {
          if (!SELECTED_NODE) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          const result = await SELECTED_NODE.validate();
          console.log(result);
        }
      },
      {
        icon: "delete_sweep",
        tooltip: "Clear validation state of the selected item",
        action: () => {
          if (!SELECTED_NODE) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if ("id" in SELECTED_NODE) {
            SELECTED_NODE.resetField();
            return;
          }
          SELECTED_NODE.resetForm();
        }
      }
    ]
  });
  api.on.getInspectorTree((payload) => {
    if (payload.inspectorId !== INSPECTOR_ID) {
      return;
    }
    const forms = Object.values(DEVTOOLS_FORMS);
    const fields = Object.values(DEVTOOLS_FIELDS);
    payload.rootNodes = [
      ...forms.map(mapFormForDevtoolsInspector),
      ...fields.map((field) => mapFieldForDevtoolsInspector(field))
    ];
  });
  api.on.getInspectorState((payload, ctx) => {
    if (payload.inspectorId !== INSPECTOR_ID || ctx.currentTab !== `custom-inspector:${INSPECTOR_ID}`) {
      return;
    }
    const { form, field, type } = decodeNodeId(payload.nodeId);
    if (form && type === "form") {
      payload.state = buildFormState(form);
      SELECTED_NODE = form;
      return;
    }
    if (field && type === "field") {
      payload.state = buildFieldState(field);
      SELECTED_NODE = field;
      return;
    }
    SELECTED_NODE = null;
  });
}
function mapFormForDevtoolsInspector(form) {
  const { textColor, bgColor } = getTagTheme(form);
  const formTreeNodes = {};
  Object.values(form.fieldsByPath.value).forEach((field) => {
    const fieldInstance = Array.isArray(field) ? field[0] : field;
    if (!fieldInstance) {
      return;
    }
    setInPath(formTreeNodes, unref(fieldInstance.name), mapFieldForDevtoolsInspector(fieldInstance, form));
  });
  function buildFormTree(tree, path = []) {
    const key = [...path].pop();
    if ("id" in tree) {
      return Object.assign(Object.assign({}, tree), { label: key || tree.label });
    }
    if (isObject(tree)) {
      return {
        id: `${path.join(".")}`,
        label: key || "",
        children: Object.keys(tree).map((key2) => buildFormTree(tree[key2], [...path, key2]))
      };
    }
    if (Array.isArray(tree)) {
      return {
        id: `${path.join(".")}`,
        label: `${key}[]`,
        children: tree.map((c, idx) => buildFormTree(c, [...path, String(idx)]))
      };
    }
    return { id: "", label: "", children: [] };
  }
  const { children } = buildFormTree(formTreeNodes);
  return {
    id: encodeNodeId(form),
    label: "Form",
    children,
    tags: [
      {
        label: "Form",
        textColor,
        backgroundColor: bgColor
      },
      {
        label: `${Object.keys(form.fieldsByPath.value).length} fields`,
        textColor: COLORS.white,
        backgroundColor: COLORS.unknown
      }
    ]
  };
}
function mapFieldForDevtoolsInspector(field, form) {
  const fieldInstance = normalizeField(field);
  const { textColor, bgColor } = getTagTheme(fieldInstance);
  const isGroup = Array.isArray(field) && field.length > 1;
  return {
    id: encodeNodeId(form, fieldInstance, !isGroup),
    label: unref(fieldInstance.name),
    children: Array.isArray(field) ? field.map((fieldItem) => mapFieldForDevtoolsInspector(fieldItem, form)) : void 0,
    tags: [
      isGroup ? void 0 : {
        label: "Field",
        textColor,
        backgroundColor: bgColor
      },
      !form ? {
        label: "Standalone",
        textColor: COLORS.black,
        backgroundColor: COLORS.gray
      } : void 0,
      !isGroup && fieldInstance.type === "checkbox" ? {
        label: "Checkbox",
        textColor: COLORS.white,
        backgroundColor: COLORS.blue
      } : void 0,
      !isGroup && fieldInstance.type === "radio" ? {
        label: "Radio",
        textColor: COLORS.white,
        backgroundColor: COLORS.purple
      } : void 0,
      isGroup ? {
        label: "Group",
        textColor: COLORS.black,
        backgroundColor: COLORS.orange
      } : void 0
    ].filter(Boolean)
  };
}
function encodeNodeId(form, field, encodeIndex = true) {
  const fieldPath = form ? unref(field === null || field === void 0 ? void 0 : field.name) : field === null || field === void 0 ? void 0 : field.id;
  const fieldGroup = fieldPath ? form === null || form === void 0 ? void 0 : form.fieldsByPath.value[fieldPath] : void 0;
  let idx;
  if (encodeIndex && field && Array.isArray(fieldGroup)) {
    idx = fieldGroup.indexOf(field);
  }
  const idObject = { f: form === null || form === void 0 ? void 0 : form.formId, ff: fieldPath, idx, type: field ? "field" : "form" };
  return btoa(JSON.stringify(idObject));
}
function decodeNodeId(nodeId) {
  try {
    const idObject = JSON.parse(atob(nodeId));
    const form = DEVTOOLS_FORMS[idObject.f];
    if (!form && idObject.ff) {
      const field = DEVTOOLS_FIELDS[idObject.ff];
      if (!field) {
        return {};
      }
      return {
        type: idObject.type,
        field
      };
    }
    if (!form) {
      return {};
    }
    const fieldGroup = form.fieldsByPath.value[idObject.ff];
    return {
      type: idObject.type,
      form,
      field: Array.isArray(fieldGroup) ? fieldGroup[idObject.idx || 0] : fieldGroup
    };
  } catch (err) {
  }
  return {};
}
function buildFieldState(field) {
  const { errors, meta, value } = field;
  return {
    "Field state": [
      { key: "errors", value: errors.value },
      {
        key: "initialValue",
        value: meta.initialValue
      },
      {
        key: "currentValue",
        value: value.value
      },
      {
        key: "touched",
        value: meta.touched
      },
      {
        key: "dirty",
        value: meta.dirty
      },
      {
        key: "valid",
        value: meta.valid
      }
    ]
  };
}
function buildFormState(form) {
  const { errorBag, meta, values, isSubmitting, submitCount } = form;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: submitCount.value
      },
      {
        key: "isSubmitting",
        value: isSubmitting.value
      },
      {
        key: "touched",
        value: meta.value.touched
      },
      {
        key: "dirty",
        value: meta.value.dirty
      },
      {
        key: "valid",
        value: meta.value.valid
      },
      {
        key: "initialValues",
        value: meta.value.initialValues
      },
      {
        key: "currentValues",
        value: values
      },
      {
        key: "errors",
        value: keysOf(errorBag.value).reduce((acc, key) => {
          var _a;
          const message = (_a = errorBag.value[key]) === null || _a === void 0 ? void 0 : _a[0];
          if (message) {
            acc[key] = message;
          }
          return acc;
        }, {})
      }
    ]
  };
}
function getTagTheme(fieldOrForm) {
  const isValid = "id" in fieldOrForm ? fieldOrForm.meta.valid : fieldOrForm.meta.value.valid;
  return {
    bgColor: isValid ? COLORS.success : COLORS.error,
    textColor: isValid ? COLORS.black : COLORS.white
  };
}
function useField(name, rules, opts) {
  if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {
    return useCheckboxField(name, rules, opts);
  }
  return _useField(name, rules, opts);
}
function _useField(name, rules, opts) {
  const { initialValue: modelValue, validateOnMount, bails, type, checkedValue, label, validateOnValueUpdate, uncheckedValue, standalone } = normalizeOptions(unref(name), opts);
  const form = !standalone ? injectWithSelf(FormContextKey) : void 0;
  const { id, value, initialValue, meta, setState, errors, errorMessage } = useFieldState(name, {
    modelValue,
    standalone
  });
  const handleBlur = () => {
    meta.touched = true;
  };
  const normalizedRules = computed(() => {
    let rulesValue = unref(rules);
    const schema = unref(form === null || form === void 0 ? void 0 : form.schema);
    if (schema && !isYupValidator(schema)) {
      rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;
    }
    if (isYupValidator(rulesValue) || isCallable(rulesValue)) {
      return rulesValue;
    }
    return normalizeRules(rulesValue);
  });
  async function validateCurrentValue(mode) {
    var _a, _b;
    if (form === null || form === void 0 ? void 0 : form.validateSchema) {
      return (_a = (await form.validateSchema(mode)).results[unref(name)]) !== null && _a !== void 0 ? _a : { valid: true, errors: [] };
    }
    return validate(value.value, normalizedRules.value, {
      name: unref(label) || unref(name),
      values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},
      bails
    });
  }
  async function validateWithStateMutation() {
    meta.pending = true;
    meta.validated = true;
    const result = await validateCurrentValue("validated-only");
    setState({ errors: result.errors });
    meta.pending = false;
    return result;
  }
  async function validateValidStateOnly() {
    const result = await validateCurrentValue("silent");
    meta.valid = result.valid;
    return result;
  }
  function validate$1(opts2) {
    if (!(opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "force") {
      return validateWithStateMutation();
    }
    if ((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "validated-only") {
      return validateWithStateMutation();
    }
    return validateValidStateOnly();
  }
  const handleChange = (e, shouldValidate = true) => {
    const newValue = normalizeEventValue(e);
    value.value = newValue;
    if (!validateOnValueUpdate && shouldValidate) {
      validateWithStateMutation();
    }
  };
  onMounted(() => {
    if (validateOnMount) {
      return validateWithStateMutation();
    }
    if (!form || !form.validateSchema) {
      validateValidStateOnly();
    }
  });
  function setTouched(isTouched) {
    meta.touched = isTouched;
  }
  let unwatchValue;
  function watchValue() {
    unwatchValue = watch(value, validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly, {
      deep: true
    });
  }
  watchValue();
  function resetField(state) {
    var _a;
    unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();
    const newValue = state && "value" in state ? state.value : initialValue.value;
    setState({
      value: klona(newValue),
      initialValue: klona(newValue),
      touched: (_a = state === null || state === void 0 ? void 0 : state.touched) !== null && _a !== void 0 ? _a : false,
      errors: (state === null || state === void 0 ? void 0 : state.errors) || []
    });
    meta.pending = false;
    meta.validated = false;
    validateValidStateOnly();
    nextTick(() => {
      watchValue();
    });
  }
  function setValue(newValue) {
    value.value = newValue;
  }
  function setErrors(errors2) {
    setState({ errors: Array.isArray(errors2) ? errors2 : [errors2] });
  }
  const field = {
    id,
    name,
    label,
    value,
    meta,
    errors,
    errorMessage,
    type,
    checkedValue,
    uncheckedValue,
    bails,
    resetField,
    handleReset: () => resetField(),
    validate: validate$1,
    handleChange,
    handleBlur,
    setState,
    setTouched,
    setErrors,
    setValue
  };
  provide(FieldContextKey, field);
  if (isRef(rules) && typeof unref(rules) !== "function") {
    watch(rules, (value2, oldValue) => {
      if (es6(value2, oldValue)) {
        return;
      }
      meta.validated ? validateWithStateMutation() : validateValidStateOnly();
    }, {
      deep: true
    });
  }
  if (true) {
    field._vm = getCurrentInstance();
    watch(() => Object.assign(Object.assign({ errors: errors.value }, meta), { value: value.value }), refreshInspector, {
      deep: true
    });
    if (!form) {
      registerSingleFieldWithDevtools(field);
    }
  }
  if (!form) {
    return field;
  }
  form.register(field);
  onBeforeUnmount(() => {
    form.unregister(field);
  });
  const dependencies = computed(() => {
    const rulesVal = normalizedRules.value;
    if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal)) {
      return {};
    }
    return Object.keys(rulesVal).reduce((acc, rule) => {
      const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
        const depValue = getFromPath(form.values, depName) || form.values[depName];
        if (depValue !== void 0) {
          depAcc[depName] = depValue;
        }
        return depAcc;
      }, {});
      Object.assign(acc, deps);
      return acc;
    }, {});
  });
  watch(dependencies, (deps, oldDeps) => {
    if (!Object.keys(deps).length) {
      return;
    }
    const shouldValidate = !es6(deps, oldDeps);
    if (shouldValidate) {
      meta.validated ? validateWithStateMutation() : validateValidStateOnly();
    }
  });
  return field;
}
function normalizeOptions(name, opts) {
  const defaults = () => ({
    initialValue: void 0,
    validateOnMount: false,
    bails: true,
    rules: "",
    label: name,
    validateOnValueUpdate: true,
    standalone: false
  });
  if (!opts) {
    return defaults();
  }
  const checkedValue = "valueProp" in opts ? opts.valueProp : opts.checkedValue;
  return Object.assign(Object.assign(Object.assign({}, defaults()), opts || {}), { checkedValue });
}
function extractRuleFromSchema(schema, fieldName) {
  if (!schema) {
    return void 0;
  }
  return schema[fieldName];
}
function useCheckboxField(name, rules, opts) {
  const form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : void 0;
  const checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;
  const uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;
  function patchCheckboxApi(field) {
    const handleChange = field.handleChange;
    const checked = computed(() => {
      const currentValue = unref(field.value);
      const checkedVal = unref(checkedValue);
      return Array.isArray(currentValue) ? currentValue.includes(checkedVal) : checkedVal === currentValue;
    });
    function handleCheckboxChange(e, shouldValidate = true) {
      var _a, _b;
      if (checked.value === ((_b = (_a = e) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {
        return;
      }
      let newValue = normalizeEventValue(e);
      if (!form) {
        newValue = resolveNextCheckboxValue(unref(field.value), unref(checkedValue), unref(uncheckedValue));
      }
      handleChange(newValue, shouldValidate);
    }
    onBeforeUnmount(() => {
      if (checked.value) {
        handleCheckboxChange(unref(checkedValue), false);
      }
    });
    return Object.assign(Object.assign({}, field), {
      checked,
      checkedValue,
      uncheckedValue,
      handleChange: handleCheckboxChange
    });
  }
  return patchCheckboxApi(_useField(name, rules, opts));
}
var FieldImpl = defineComponent({
  name: "Field",
  inheritAttrs: false,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: true
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => getConfig().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: IS_ABSENT
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: false
    }
  },
  setup(props2, ctx) {
    const rules = toRef(props2, "rules");
    const name = toRef(props2, "name");
    const label = toRef(props2, "label");
    const uncheckedValue = toRef(props2, "uncheckedValue");
    const hasModelEvents = isPropPresent(props2, "onUpdate:modelValue");
    const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, setTouched, resetField, handleReset, meta, checked, setErrors } = useField(name, rules, {
      validateOnMount: props2.validateOnMount,
      bails: props2.bails,
      standalone: props2.standalone,
      type: ctx.attrs.type,
      initialValue: resolveInitialValue(props2, ctx),
      checkedValue: ctx.attrs.value,
      uncheckedValue,
      label,
      validateOnValueUpdate: false
    });
    const onChangeHandler = hasModelEvents ? function handleChangeWithModel(e, shouldValidate = true) {
      handleChange(e, shouldValidate);
      ctx.emit("update:modelValue", value.value);
    } : handleChange;
    const handleInput = (e) => {
      if (!hasCheckedAttr(ctx.attrs.type)) {
        value.value = normalizeEventValue(e);
      }
    };
    const onInputHandler = hasModelEvents ? function handleInputWithModel(e) {
      handleInput(e);
      ctx.emit("update:modelValue", value.value);
    } : handleInput;
    const fieldProps = computed(() => {
      const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props2);
      const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : void 0].filter(Boolean);
      const baseOnInput = [(e) => onChangeHandler(e, validateOnInput), ctx.attrs.onInput].filter(Boolean);
      const baseOnChange = [(e) => onChangeHandler(e, validateOnChange), ctx.attrs.onChange].filter(Boolean);
      const attrs = {
        name: props2.name,
        onBlur: baseOnBlur,
        onInput: baseOnInput,
        onChange: baseOnChange
      };
      if (validateOnModelUpdate) {
        attrs["onUpdate:modelValue"] = [onChangeHandler];
      }
      if (hasCheckedAttr(ctx.attrs.type) && checked) {
        attrs.checked = checked.value;
      } else {
        attrs.value = value.value;
      }
      const tag = resolveTag(props2, ctx);
      if (shouldHaveValueBinding(tag, ctx.attrs)) {
        delete attrs.value;
      }
      return attrs;
    });
    const modelValue = toRef(props2, "modelValue");
    watch(modelValue, (newModelValue) => {
      if (newModelValue === IS_ABSENT && value.value === void 0) {
        return;
      }
      if (newModelValue !== applyModifiers(value.value, props2.modelModifiers)) {
        value.value = newModelValue === IS_ABSENT ? void 0 : newModelValue;
        validateField();
      }
    });
    function slotProps() {
      return {
        field: fieldProps.value,
        value: value.value,
        meta,
        errors: errors.value,
        errorMessage: errorMessage.value,
        validate: validateField,
        resetField,
        handleChange: onChangeHandler,
        handleInput: onInputHandler,
        handleReset,
        handleBlur,
        setTouched,
        setErrors
      };
    }
    ctx.expose({
      setErrors,
      setTouched,
      reset: resetField,
      validate: validateField,
      handleChange
    });
    return () => {
      const tag = resolveDynamicComponent(resolveTag(props2, ctx));
      const children = normalizeChildren(tag, ctx, slotProps);
      if (tag) {
        return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);
      }
      return children;
    };
  }
});
function resolveTag(props2, ctx) {
  let tag = props2.as || "";
  if (!props2.as && !ctx.slots.default) {
    tag = "input";
  }
  return tag;
}
function resolveValidationTriggers(props2) {
  var _a, _b, _c, _d;
  const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();
  return {
    validateOnInput: (_a = props2.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,
    validateOnChange: (_b = props2.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,
    validateOnBlur: (_c = props2.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,
    validateOnModelUpdate: (_d = props2.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate
  };
}
function applyModifiers(value, modifiers) {
  if (modifiers.number) {
    return toNumber(value);
  }
  return value;
}
function resolveInitialValue(props2, ctx) {
  if (!hasCheckedAttr(ctx.attrs.type)) {
    return isPropPresent(props2, "modelValue") ? props2.modelValue : ctx.attrs.value;
  }
  return isPropPresent(props2, "modelValue") ? props2.modelValue : void 0;
}
var FORM_COUNTER = 0;
function useForm(opts) {
  const formId = FORM_COUNTER++;
  let RESET_LOCK = false;
  const fieldsByPath = ref({});
  const isSubmitting = ref(false);
  const submitCount = ref(0);
  const fieldArraysLookup = {};
  const formValues = reactive(klona(unref(opts === null || opts === void 0 ? void 0 : opts.initialValues) || {}));
  const { errorBag, setErrorBag, setFieldErrorBag } = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors);
  const errors = computed(() => {
    return keysOf(errorBag.value).reduce((acc, key) => {
      const bag = errorBag.value[key];
      if (bag && bag.length) {
        acc[key] = bag[0];
      }
      return acc;
    }, {});
  });
  function getFirstFieldAtPath(path) {
    const fieldOrGroup = fieldsByPath.value[path];
    return Array.isArray(fieldOrGroup) ? fieldOrGroup[0] : fieldOrGroup;
  }
  function fieldExists(path) {
    return !!fieldsByPath.value[path];
  }
  const fieldNames = computed(() => {
    return keysOf(fieldsByPath.value).reduce((names, path) => {
      const field = getFirstFieldAtPath(path);
      if (field) {
        names[path] = unref(field.label || field.name) || "";
      }
      return names;
    }, {});
  });
  const fieldBailsMap = computed(() => {
    return keysOf(fieldsByPath.value).reduce((map, path) => {
      var _a;
      const field = getFirstFieldAtPath(path);
      if (field) {
        map[path] = (_a = field.bails) !== null && _a !== void 0 ? _a : true;
      }
      return map;
    }, {});
  });
  const initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});
  const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(fieldsByPath, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);
  const meta = useFormMeta(fieldsByPath, formValues, initialValues, errors);
  const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;
  const formCtx = {
    formId,
    fieldsByPath,
    values: formValues,
    errorBag,
    errors,
    schema,
    submitCount,
    meta,
    isSubmitting,
    fieldArraysLookup,
    validateSchema: unref(schema) ? validateSchema : void 0,
    validate: validate2,
    register: registerField,
    unregister: unregisterField,
    setFieldErrorBag,
    validateField,
    setFieldValue,
    setValues,
    setErrors,
    setFieldError,
    setFieldTouched,
    setTouched,
    resetForm,
    handleSubmit,
    stageInitialValue,
    unsetInitialValue,
    setFieldInitialValue
  };
  function isFieldGroup(fieldOrGroup) {
    return Array.isArray(fieldOrGroup);
  }
  function applyFieldMutation(fieldOrGroup, mutation) {
    if (Array.isArray(fieldOrGroup)) {
      return fieldOrGroup.forEach(mutation);
    }
    return mutation(fieldOrGroup);
  }
  function setFieldError(field, message) {
    setFieldErrorBag(field, message);
  }
  function setErrors(fields) {
    setErrorBag(fields);
  }
  function setFieldValue(field, value, { force } = { force: false }) {
    var _a;
    const fieldInstance = fieldsByPath.value[field];
    const clonedValue = klona(value);
    if (!fieldInstance) {
      setInPath(formValues, field, clonedValue);
      return;
    }
    if (isFieldGroup(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === "checkbox" && !Array.isArray(value)) {
      const newValue2 = klona(resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, void 0));
      setInPath(formValues, field, newValue2);
      return;
    }
    let newValue = value;
    if (!isFieldGroup(fieldInstance) && fieldInstance.type === "checkbox" && !force && !RESET_LOCK) {
      newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue)));
    }
    setInPath(formValues, field, newValue);
  }
  function setValues(fields) {
    keysOf(formValues).forEach((key) => {
      delete formValues[key];
    });
    keysOf(fields).forEach((path) => {
      setFieldValue(path, fields[path]);
    });
    Object.values(fieldArraysLookup).forEach((f) => f && f.reset());
  }
  function setFieldTouched(field, isTouched) {
    const fieldInstance = fieldsByPath.value[field];
    if (fieldInstance) {
      applyFieldMutation(fieldInstance, (f) => f.setTouched(isTouched));
    }
  }
  function setTouched(fields) {
    keysOf(fields).forEach((field) => {
      setFieldTouched(field, !!fields[field]);
    });
  }
  function resetForm(state) {
    RESET_LOCK = true;
    if (state === null || state === void 0 ? void 0 : state.values) {
      setInitialValues(state.values);
      setValues(state === null || state === void 0 ? void 0 : state.values);
    } else {
      setInitialValues(originalInitialValues.value);
      setValues(originalInitialValues.value);
    }
    Object.values(fieldsByPath.value).forEach((field) => {
      if (!field) {
        return;
      }
      applyFieldMutation(field, (f) => f.resetField());
    });
    if (state === null || state === void 0 ? void 0 : state.touched) {
      setTouched(state.touched);
    }
    setErrors((state === null || state === void 0 ? void 0 : state.errors) || {});
    submitCount.value = (state === null || state === void 0 ? void 0 : state.submitCount) || 0;
    nextTick(() => {
      RESET_LOCK = false;
    });
  }
  function insertFieldAtPath(field, path) {
    const rawField = markRaw(field);
    const fieldPath = path;
    if (!fieldsByPath.value[fieldPath]) {
      fieldsByPath.value[fieldPath] = rawField;
      return;
    }
    const fieldAtPath = fieldsByPath.value[fieldPath];
    if (fieldAtPath && !Array.isArray(fieldAtPath)) {
      fieldsByPath.value[fieldPath] = [fieldAtPath];
    }
    fieldsByPath.value[fieldPath] = [...fieldsByPath.value[fieldPath], rawField];
  }
  function removeFieldFromPath(field, path) {
    const fieldPath = path;
    const fieldAtPath = fieldsByPath.value[fieldPath];
    if (!fieldAtPath) {
      return;
    }
    if (!isFieldGroup(fieldAtPath) && field.id === fieldAtPath.id) {
      delete fieldsByPath.value[fieldPath];
      return;
    }
    if (isFieldGroup(fieldAtPath)) {
      const idx = fieldAtPath.findIndex((f) => f.id === field.id);
      if (idx === -1) {
        return;
      }
      fieldAtPath.splice(idx, 1);
      if (fieldAtPath.length === 1) {
        fieldsByPath.value[fieldPath] = fieldAtPath[0];
        return;
      }
      if (!fieldAtPath.length) {
        delete fieldsByPath.value[fieldPath];
      }
    }
  }
  function registerField(field) {
    const fieldPath = unref(field.name);
    insertFieldAtPath(field, fieldPath);
    if (isRef(field.name)) {
      watch(field.name, async (newPath, oldPath) => {
        await nextTick();
        removeFieldFromPath(field, oldPath);
        insertFieldAtPath(field, newPath);
        if (errors.value[oldPath] || errors.value[newPath]) {
          validateField(newPath);
        }
        await nextTick();
        if (!fieldExists(oldPath)) {
          unsetPath(formValues, oldPath);
        }
      });
    }
    const initialErrorMessage = unref(field.errorMessage);
    if (initialErrorMessage && (initialErrors === null || initialErrors === void 0 ? void 0 : initialErrors[fieldPath]) !== initialErrorMessage) {
      validateField(fieldPath);
    }
    delete initialErrors[fieldPath];
  }
  function unregisterField(field) {
    const fieldName = unref(field.name);
    removeFieldFromPath(field, fieldName);
    nextTick(() => {
      if (!fieldExists(fieldName)) {
        setFieldError(fieldName, void 0);
        unsetPath(formValues, fieldName);
      }
    });
  }
  async function validate2(opts2) {
    if (formCtx.validateSchema) {
      return formCtx.validateSchema((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "force");
    }
    const validations = await Promise.all(Object.values(fieldsByPath.value).map((field) => {
      const fieldInstance = Array.isArray(field) ? field[0] : field;
      if (!fieldInstance) {
        return Promise.resolve({ key: "", valid: true, errors: [] });
      }
      return fieldInstance.validate(opts2).then((result) => {
        return {
          key: unref(fieldInstance.name),
          valid: result.valid,
          errors: result.errors
        };
      });
    }));
    const results = {};
    const errors2 = {};
    for (const validation of validations) {
      results[validation.key] = {
        valid: validation.valid,
        errors: validation.errors
      };
      if (validation.errors.length) {
        errors2[validation.key] = validation.errors[0];
      }
    }
    return {
      valid: validations.every((r) => r.valid),
      results,
      errors: errors2
    };
  }
  async function validateField(field) {
    const fieldInstance = fieldsByPath.value[field];
    if (!fieldInstance) {
      warn(`field with name ${field} was not found`);
      return Promise.resolve({ errors: [], valid: true });
    }
    if (Array.isArray(fieldInstance)) {
      return fieldInstance.map((f) => f.validate())[0];
    }
    return fieldInstance.validate();
  }
  function handleSubmit(fn, onValidationError) {
    return function submissionHandler(e) {
      if (e instanceof Event) {
        e.preventDefault();
        e.stopPropagation();
      }
      setTouched(keysOf(fieldsByPath.value).reduce((acc, field) => {
        acc[field] = true;
        return acc;
      }, {}));
      isSubmitting.value = true;
      submitCount.value++;
      return validate2().then((result) => {
        if (result.valid && typeof fn === "function") {
          return fn(klona(formValues), {
            evt: e,
            setErrors,
            setFieldError,
            setTouched,
            setFieldTouched,
            setValues,
            setFieldValue,
            resetForm
          });
        }
        if (!result.valid && typeof onValidationError === "function") {
          onValidationError({
            values: klona(formValues),
            evt: e,
            errors: result.errors,
            results: result.results
          });
        }
      }).then((returnVal) => {
        isSubmitting.value = false;
        return returnVal;
      }, (err) => {
        isSubmitting.value = false;
        throw err;
      });
    };
  }
  function setFieldInitialValue(path, value) {
    setInPath(initialValues.value, path, klona(value));
  }
  function unsetInitialValue(path) {
    unsetPath(initialValues.value, path);
  }
  function stageInitialValue(path, value) {
    setInPath(formValues, path, value);
    setFieldInitialValue(path, value);
  }
  async function _validateSchema() {
    const schemaValue = unref(schema);
    if (!schemaValue) {
      return { valid: true, results: {}, errors: {} };
    }
    const formResult = isYupValidator(schemaValue) ? await validateYupSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
      names: fieldNames.value,
      bailsMap: fieldBailsMap.value
    });
    return formResult;
  }
  const debouncedSchemaValidation = debounceAsync(_validateSchema, 5);
  async function validateSchema(mode) {
    const formResult = await debouncedSchemaValidation();
    const fieldsById = formCtx.fieldsByPath.value || {};
    const currentErrorsPaths = keysOf(formCtx.errorBag.value);
    const paths = [
      ...new Set([...keysOf(formResult.results), ...keysOf(fieldsById), ...currentErrorsPaths])
    ];
    return paths.reduce((validation, path) => {
      const field = fieldsById[path];
      const messages = (formResult.results[path] || { errors: [] }).errors;
      const fieldResult = {
        errors: messages,
        valid: !messages.length
      };
      validation.results[path] = fieldResult;
      if (!fieldResult.valid) {
        validation.errors[path] = fieldResult.errors[0];
      }
      if (!field) {
        setFieldError(path, messages);
        return validation;
      }
      applyFieldMutation(field, (f) => f.meta.valid = fieldResult.valid);
      if (mode === "silent") {
        return validation;
      }
      const wasValidated = Array.isArray(field) ? field.some((f) => f.meta.validated) : field.meta.validated;
      if (mode === "validated-only" && !wasValidated) {
        return validation;
      }
      applyFieldMutation(field, (f) => f.setState({ errors: fieldResult.errors }));
      return validation;
    }, { valid: formResult.valid, results: {}, errors: {} });
  }
  const submitForm = handleSubmit((_, { evt }) => {
    if (isFormSubmitEvent(evt)) {
      evt.target.submit();
    }
  });
  onMounted(() => {
    if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
      setErrors(opts.initialErrors);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
      setTouched(opts.initialTouched);
    }
    if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
      validate2();
      return;
    }
    if (formCtx.validateSchema) {
      formCtx.validateSchema("silent");
    }
  });
  if (isRef(schema)) {
    watch(schema, () => {
      var _a;
      (_a = formCtx.validateSchema) === null || _a === void 0 ? void 0 : _a.call(formCtx, "validated-only");
    });
  }
  provide(FormContextKey, formCtx);
  if (true) {
    registerFormWithDevTools(formCtx);
    watch(() => Object.assign(Object.assign({ errors: errorBag.value }, meta.value), { values: formValues, isSubmitting: isSubmitting.value, submitCount: submitCount.value }), refreshInspector, {
      deep: true
    });
  }
  return {
    errors,
    meta,
    values: formValues,
    isSubmitting,
    submitCount,
    validate: validate2,
    validateField,
    handleReset: () => resetForm(),
    resetForm,
    handleSubmit,
    submitForm,
    setFieldError,
    setErrors,
    setFieldValue,
    setValues,
    setFieldTouched,
    setTouched
  };
}
function useFormMeta(fieldsByPath, currentValues, initialValues, errors) {
  const MERGE_STRATEGIES = {
    touched: "some",
    pending: "some",
    valid: "every"
  };
  const isDirty = computed(() => {
    return !es6(currentValues, unref(initialValues));
  });
  const flags = computed(() => {
    const fields = Object.values(fieldsByPath.value).flat(1).filter(Boolean);
    return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
      const mergeMethod = MERGE_STRATEGIES[flag];
      acc[flag] = fields[mergeMethod]((field) => field.meta[flag]);
      return acc;
    }, {});
  });
  return computed(() => {
    return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags.value), { valid: flags.value.valid && !keysOf(errors.value).length, dirty: isDirty.value });
  });
}
function useFormInitialValues(fields, formValues, providedValues) {
  const initialValues = ref(klona(unref(providedValues)) || {});
  const originalInitialValues = ref(klona(unref(providedValues)) || {});
  function setInitialValues(values, updateFields = false) {
    initialValues.value = klona(values);
    originalInitialValues.value = klona(values);
    if (!updateFields) {
      return;
    }
    keysOf(fields.value).forEach((fieldPath) => {
      const field = fields.value[fieldPath];
      const wasTouched = Array.isArray(field) ? field.some((f) => f.meta.touched) : field === null || field === void 0 ? void 0 : field.meta.touched;
      if (!field || wasTouched) {
        return;
      }
      const newValue = getFromPath(initialValues.value, fieldPath);
      setInPath(formValues, fieldPath, klona(newValue));
    });
  }
  if (isRef(providedValues)) {
    watch(providedValues, (value) => {
      setInitialValues(value, true);
    }, {
      deep: true
    });
  }
  return {
    initialValues,
    originalInitialValues,
    setInitialValues
  };
}
function useErrorBag(initialErrors) {
  const errorBag = ref({});
  function normalizeErrorItem(message) {
    return Array.isArray(message) ? message : message ? [message] : [];
  }
  function setFieldErrorBag(field, message) {
    if (!message) {
      delete errorBag.value[field];
      return;
    }
    errorBag.value[field] = normalizeErrorItem(message);
  }
  function setErrorBag(fields) {
    errorBag.value = keysOf(fields).reduce((acc, key) => {
      const message = fields[key];
      if (message) {
        acc[key] = normalizeErrorItem(message);
      }
      return acc;
    }, {});
  }
  if (initialErrors) {
    setErrorBag(initialErrors);
  }
  return {
    errorBag,
    setErrorBag,
    setFieldErrorBag
  };
}
var FormImpl = defineComponent({
  name: "Form",
  inheritAttrs: false,
  props: {
    as: {
      type: String,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    }
  },
  setup(props2, ctx) {
    const initialValues = toRef(props2, "initialValues");
    const validationSchema = toRef(props2, "validationSchema");
    const { errors, values, meta, isSubmitting, submitCount, validate: validate2, validateField, handleReset, resetForm, handleSubmit, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched } = useForm({
      validationSchema: validationSchema.value ? validationSchema : void 0,
      initialValues,
      initialErrors: props2.initialErrors,
      initialTouched: props2.initialTouched,
      validateOnMount: props2.validateOnMount
    });
    const onSubmit = props2.onSubmit ? handleSubmit(props2.onSubmit, props2.onInvalidSubmit) : submitForm;
    function handleFormReset(e) {
      if (isEvent(e)) {
        e.preventDefault();
      }
      handleReset();
      if (typeof ctx.attrs.onReset === "function") {
        ctx.attrs.onReset();
      }
    }
    function handleScopedSlotSubmit(evt, onSubmit2) {
      const onSuccess = typeof evt === "function" && !onSubmit2 ? evt : onSubmit2;
      return handleSubmit(onSuccess, props2.onInvalidSubmit)(evt);
    }
    function slotProps() {
      return {
        meta: meta.value,
        errors: errors.value,
        values,
        isSubmitting: isSubmitting.value,
        submitCount: submitCount.value,
        validate: validate2,
        validateField,
        handleSubmit: handleScopedSlotSubmit,
        handleReset,
        submitForm,
        setErrors,
        setFieldError,
        setFieldValue,
        setValues,
        setFieldTouched,
        setTouched,
        resetForm
      };
    }
    ctx.expose({
      setFieldError,
      setErrors,
      setFieldValue,
      setValues,
      setFieldTouched,
      setTouched,
      resetForm,
      validate: validate2,
      validateField
    });
    return function renderForm() {
      const tag = props2.as === "form" ? props2.as : resolveDynamicComponent(props2.as);
      const children = normalizeChildren(tag, ctx, slotProps);
      if (!props2.as) {
        return children;
      }
      const formAttrs = props2.as === "form" ? {
        novalidate: true
      } : {};
      return h(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);
    };
  }
});
var FIELD_ARRAY_COUNTER = 0;
function useFieldArray(arrayPath) {
  const id = FIELD_ARRAY_COUNTER++;
  const form = injectWithSelf(FormContextKey, void 0);
  const fields = ref([]);
  const noOp = () => {
  };
  const noOpApi = {
    fields: readonly(fields),
    remove: noOp,
    push: noOp,
    swap: noOp,
    insert: noOp,
    update: noOp,
    replace: noOp,
    prepend: noOp
  };
  if (!form) {
    warn2("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly");
    return noOpApi;
  }
  if (!unref(arrayPath)) {
    warn2("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?");
    return noOpApi;
  }
  let entryCounter = 0;
  function initFields() {
    const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []);
    fields.value = currentValues.map(createEntry);
    updateEntryFlags();
  }
  initFields();
  function updateEntryFlags() {
    const fieldsLength = fields.value.length;
    for (let i = 0; i < fieldsLength; i++) {
      const entry = fields.value[i];
      entry.isFirst = i === 0;
      entry.isLast = i === fieldsLength - 1;
    }
  }
  function createEntry(value) {
    const key = entryCounter++;
    const entry = {
      key,
      value: computed(() => {
        const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []);
        const idx = fields.value.findIndex((e) => e.key === key);
        return idx === -1 ? value : currentValues[idx];
      }),
      isFirst: false,
      isLast: false
    };
    return entry;
  }
  function remove(idx) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!pathValue || !Array.isArray(pathValue)) {
      return;
    }
    const newValue = [...pathValue];
    newValue.splice(idx, 1);
    form === null || form === void 0 ? void 0 : form.unsetInitialValue(pathName + `[${idx}]`);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.splice(idx, 1);
    updateEntryFlags();
  }
  function push(value) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
    if (!Array.isArray(normalizedPathValue)) {
      return;
    }
    const newValue = [...normalizedPathValue];
    newValue.push(value);
    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.push(createEntry(value));
    updateEntryFlags();
  }
  function swap(indexA, indexB) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || !pathValue[indexA] || !pathValue[indexB]) {
      return;
    }
    const newValue = [...pathValue];
    const newFields = [...fields.value];
    const temp = newValue[indexA];
    newValue[indexA] = newValue[indexB];
    newValue[indexB] = temp;
    const tempEntry = newFields[indexA];
    newFields[indexA] = newFields[indexB];
    newFields[indexB] = tempEntry;
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value = newFields;
    updateEntryFlags();
  }
  function insert(idx, value) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || pathValue.length < idx) {
      return;
    }
    const newValue = [...pathValue];
    const newFields = [...fields.value];
    newValue.splice(idx, 0, value);
    newFields.splice(idx, 0, createEntry(value));
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value = newFields;
    updateEntryFlags();
  }
  function replace(arr) {
    const pathName = unref(arrayPath);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, arr);
    initFields();
  }
  function update(idx, value) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || pathValue.length - 1 < idx) {
      return;
    }
    form === null || form === void 0 ? void 0 : form.setFieldValue(`${pathName}[${idx}]`, value);
  }
  function prepend(value) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
    if (!Array.isArray(normalizedPathValue)) {
      return;
    }
    const newValue = [value, ...normalizedPathValue];
    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.unshift(createEntry(value));
    updateEntryFlags();
  }
  form.fieldArraysLookup[id] = {
    reset: initFields
  };
  onBeforeUnmount(() => {
    delete form.fieldArraysLookup[id];
  });
  return {
    fields: readonly(fields),
    remove,
    push,
    swap,
    insert,
    update,
    replace,
    prepend
  };
}
var FieldArrayImpl = defineComponent({
  name: "FieldArray",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      required: true
    }
  },
  setup(props2, ctx) {
    const { push, remove, swap, insert, replace, update, prepend, fields } = useFieldArray(toRef(props2, "name"));
    function slotProps() {
      return {
        fields: fields.value,
        push,
        remove,
        swap,
        insert,
        update,
        replace,
        prepend
      };
    }
    ctx.expose({
      push,
      remove,
      swap,
      insert,
      update,
      replace,
      prepend
    });
    return () => {
      const children = normalizeChildren(void 0, ctx, slotProps);
      return children;
    };
  }
});
var ErrorMessageImpl = defineComponent({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: true
    }
  },
  setup(props2, ctx) {
    const form = inject(FormContextKey, void 0);
    const message = computed(() => {
      return form === null || form === void 0 ? void 0 : form.errors.value[props2.name];
    });
    function slotProps() {
      return {
        message: message.value
      };
    }
    return () => {
      if (!message.value) {
        return void 0;
      }
      const tag = props2.as ? resolveDynamicComponent(props2.as) : props2.as;
      const children = normalizeChildren(tag, ctx, slotProps);
      const attrs = Object.assign({ role: "alert" }, ctx.attrs);
      if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {
        return children;
      }
      if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {
        return h(tag || "span", attrs, message.value);
      }
      return h(tag, attrs, children);
    };
  }
});

// node_modules/vue-headless-ui/dist/vue-headless-ui.esm.js
function randomString(length = 30) {
  return [...Array(length)].map(() => Math.random().toString(36)[2]).join("");
}
function isMissingInjectable(...args) {
  for (let index = 0; index < args.length; index++) {
    const element = args[index];
    if (element === void 0) {
      throw new Error("Missing injectable variable, please make sure you are using the correct wrapper component.");
    }
  }
}
var ID$1 = Symbol("ID");
var INPUT_VALUE = Symbol("INPUT_VALUE");
var NAME = Symbol("NAME");
var ERROR_MESSAGE = Symbol("ERROR_MESSAGE");
var STATE = Symbol("STATE");
var VALIDATE = Symbol("VALIDATE");
var HANDLE_BLUR = Symbol("HANDLE_BLUR");
var META = Symbol("META");
var OPTIONS = Symbol("OPTIONS");
var INPUTS = Symbol("INPUTS");
var FORM = {
  ID: ID$1,
  INPUT_VALUE,
  OPTIONS,
  NAME,
  ERROR_MESSAGE,
  STATE,
  VALIDATE,
  HANDLE_BLUR,
  META,
  INPUTS
};
var ID = Symbol("ID");
var IS_OPEN$1 = Symbol("IS_OPEN");
var DIALOG = {
  ID,
  IS_OPEN: IS_OPEN$1
};
var IS_OPEN = Symbol("IS_OPEN");
var TOGGLE = Symbol("TOGGLE");
var COMPUTED_ID = Symbol("COMPUTED_ID");
var DELAY = Symbol("DELAY");
var ACCORDION = {
  IS_OPEN,
  TOGGLE,
  COMPUTED_ID,
  DELAY
};
var TAB_ARRAY = Symbol("TAB_ARRAY");
var SWITCH_ARRAY = Symbol("SWITCH_ARRAY");
var CURRENT_TAB = Symbol("CURRENT_TAB");
var SWITCH_TAB = Symbol("SWITCH_TAB");
var TABS = {
  TAB_ARRAY,
  SWITCH_ARRAY,
  CURRENT_TAB,
  SWITCH_TAB
};
var MATRIX = Symbol("MATRIX");
var UPDATE_DAY = Symbol("UPDATE_DAY");
var UPDATE_MONTH = Symbol("UPDATE_MONTH");
var UPDATE_YEAR = Symbol("UPDATE_YEAR");
var DATE_OBJECT = Symbol("DATE_OBJECT");
var START_SUNDAY = Symbol("START_SUNDAY");
var MODEL = Symbol("MODEL");
var LOCALE = Symbol("LOCALE");
var CALENDAR = {
  MATRIX,
  UPDATE_DAY,
  UPDATE_MONTH,
  UPDATE_YEAR,
  DATE_OBJECT,
  START_SUNDAY,
  MODEL,
  LOCALE
};
var injectionKeys = {
  FORM,
  ACCORDION,
  DIALOG,
  TABS,
  CALENDAR
};
var InputState;
(function(InputState2) {
  InputState2["Clear"] = "clear";
  InputState2["Valid"] = "valid";
  InputState2["Error"] = "error";
})(InputState || (InputState = {}));
var props$1 = {
  modelValue: {
    type: [String, Number, Boolean, Array, Object],
    default: null
  },
  options: {
    type: Array,
    default: null
  },
  id: {
    type: [String, Number],
    default: null
  },
  name: {
    type: [String, Number],
    default: null
  },
  rules: {
    type: [String, Function, Object],
    default: null
  },
  group: {
    type: Boolean,
    default: false
  },
  overrideState: {
    type: String,
    default: null
  }
};
var emits$1 = {
  blur: null,
  "update:modelValue": (value) => {
    if (value === void 0) {
      console.warn("Input context returned undefined value");
      return false;
    }
    return true;
  }
};
function useFieldContext(props2, context) {
  const inputId = props2.id ? `${props2.id}` : `input-${randomString()}`;
  const inputName = props2.name ? `${props2.name}` : `${inputId}-name`;
  const {
    errorMessage,
    value,
    meta,
    validate: validate2
  } = useField(inputName, props2.rules);
  const inputValue = computed({
    get: () => props2.modelValue,
    set: (val) => {
      context.emit("update:modelValue", val);
    }
  });
  watch(inputValue, (newVal) => {
    value.value = newVal;
  });
  const state = computed(() => {
    if (props2.overrideState != null) {
      return props2.overrideState;
    }
    if (meta.touched && meta.validated) {
      if (meta.valid) {
        return InputState.Valid;
      }
      return InputState.Error;
    }
    return InputState.Clear;
  });
  async function handleBlur() {
    meta.touched = true;
    if (props2.overrideState == null)
      await validate2();
    context.emit("blur");
  }
  if (props2.modelValue) {
    value.value = props2.modelValue;
    if (Array.isArray(value.value)) {
      if (value.value.length > 0) {
        meta.touched = true;
        validate2().catch((error) => {
          console.warn(error);
        });
      }
    } else {
      meta.touched = true;
      validate2().catch((error) => {
        console.warn(error);
      });
    }
  }
  return {
    errorMessage,
    inputValue,
    inputName,
    inputId,
    meta,
    state,
    validate: validate2,
    handleBlur
  };
}
function useModel(props2, context) {
  return computed({
    get: () => props2.modelValue,
    set: (val) => {
      context.emit("update:modelValue", val);
    }
  });
}
var script$l = defineComponent({
  name: "HeadlessInput",
  props: props$1,
  emits: emits$1,
  setup(props2, context) {
    const {
      errorMessage,
      inputValue,
      inputName,
      inputId,
      state,
      validate: validate2,
      handleBlur,
      meta
    } = useFieldContext(props2, context);
    const thing = [];
    const inputs = ref([]);
    provide(injectionKeys.FORM.ID, inputId);
    provide(injectionKeys.FORM.INPUT_VALUE, inputValue);
    provide(injectionKeys.FORM.NAME, inputName);
    provide(injectionKeys.FORM.ERROR_MESSAGE, errorMessage);
    provide(injectionKeys.FORM.STATE, state);
    provide(injectionKeys.FORM.VALIDATE, validate2);
    provide(injectionKeys.FORM.HANDLE_BLUR, handleBlur);
    provide(injectionKeys.FORM.META, meta);
    provide(injectionKeys.FORM.OPTIONS, props2.options);
    provide(injectionKeys.FORM.INPUTS, inputs);
    return {
      errorMessage,
      state,
      validate: validate2,
      handleBlur,
      meta,
      inputs,
      thing
    };
  }
});
function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.group ? "fieldset" : "div"), {
    "data-input": "true"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      errorMessage: _ctx.errorMessage,
      handleBlur: _ctx.handleBlur,
      meta: _ctx.meta,
      state: _ctx.state,
      validate: _ctx.validate
    })]),
    _: 3
  });
}
script$l.render = render$l;
var emits = {
  blur: null
};
function setup$1() {
  const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
  const id = inject(injectionKeys.FORM.ID);
  const name = inject(injectionKeys.FORM.NAME);
  const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
  const state = inject(injectionKeys.FORM.STATE);
  const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
  isMissingInjectable(id, name, errorMessage, state, handleBlur);
  return {
    inputValue,
    id,
    name,
    handleBlur,
    errorMessage,
    state
  };
}
var script$k = defineComponent({
  name: "InputField",
  emits,
  setup: setup$1
});
var _hoisted_1$9 = ["id", "aria-describedby", "aria-invalid", "name"];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === "error" ? `${_ctx.id}-error` : void 0,
    "aria-invalid": _ctx.errorMessage && _ctx.state === "error" ? true : void 0,
    name: _ctx.name,
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, null, 40, _hoisted_1$9)), [[vModelText, _ctx.inputValue]]);
}
script$k.render = render$k;
var script$j = defineComponent({
  name: "TextareaField",
  emits,
  setup: setup$1
});
var _hoisted_1$8 = ["id", "aria-describedby", "aria-invalid"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("textarea", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === "error" ? `${_ctx.id}-error` : void 0,
    "aria-invalid": _ctx.errorMessage && _ctx.state === "error" ? true : void 0,
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, null, 40, _hoisted_1$8)), [[vModelText, _ctx.inputValue]]);
}
script$j.render = render$j;
var script$i = defineComponent({
  name: "SelectField",
  props: {
    placeholder: {
      type: String,
      default: null
    },
    valueKey: {
      type: String,
      default: "value"
    },
    nameKey: {
      type: String,
      default: "name"
    }
  },
  emits,
  setup() {
    const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
    const id = inject(injectionKeys.FORM.ID);
    const name = inject(injectionKeys.FORM.NAME);
    const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
    const options = inject(injectionKeys.FORM.OPTIONS);
    if (!options)
      console.warn("Missing options. Please make sure are passing options to the headless input.");
    isMissingInjectable(id, inputValue, name, handleBlur, options);
    return {
      inputValue,
      id,
      handleBlur,
      options
    };
  }
});
var _hoisted_1$7 = ["id"];
var _hoisted_2$1 = {
  key: 0,
  value: null,
  disabled: "",
  hidden: "",
  selected: ""
};
var _hoisted_3 = ["value"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("select", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, [_ctx.placeholder ? (openBlock(), createElementBlock("option", _hoisted_2$1, toDisplayString(_ctx.placeholder), 1)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
    return openBlock(), createElementBlock("option", {
      key: index,
      value: option[_ctx.valueKey]
    }, toDisplayString(option[_ctx.nameKey]), 9, _hoisted_3);
  }), 128))], 40, _hoisted_1$7)), [[vModelSelect, _ctx.inputValue]]);
}
script$i.render = render$i;
function useArrayLink(array) {
  const id = ref(randomString());
  if (!(array !== null && array !== void 0 && array.value.find((x) => x === id.value)) && id.value) {
    array === null || array === void 0 ? void 0 : array.value.push(id.value);
  }
  const index = computed(() => {
    if (array) {
      const index2 = array.value.findIndex((x) => x == id.value);
      if (index2 != null || index2 != void 0) {
        return index2;
      }
      return -1;
    }
    return -1;
  });
  onBeforeUnmount(() => {
    if (array)
      array.value = array.value.filter((x) => x != id.value);
  });
  return {
    id,
    index
  };
}
var props = {
  value: {
    type: [String, Number, Object, Array],
    default: null
  }
};
function setup() {
  const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
  const id = inject(injectionKeys.FORM.ID);
  const name = inject(injectionKeys.FORM.NAME);
  const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
  const state = inject(injectionKeys.FORM.STATE);
  const meta = inject(injectionKeys.FORM.META, {
    touched: false,
    dirty: false,
    valid: false,
    validated: false,
    pending: false,
    initialValue: null
  });
  const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
  const inputs = inject(injectionKeys.FORM.INPUTS);
  isMissingInjectable(id, inputValue, name, errorMessage, state, handleBlur, inputs);
  const {
    id: inputId
  } = useArrayLink(inputs);
  return {
    inputValue,
    id,
    inputId,
    name,
    handleBlur,
    errorMessage,
    state,
    meta
  };
}
var script$h = defineComponent({
  name: "RadioField",
  props,
  emits,
  setup
});
var _hoisted_1$6 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === "error" ? `${_ctx.id}-error` : void 0,
    "aria-invalid": _ctx.errorMessage && _ctx.state === "error" ? true : void 0,
    name: _ctx.name,
    value: _ctx.value,
    type: "radio",
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
    onChange: _cache[2] || (_cache[2] = ($event) => _ctx.meta.touched = true)
  }, null, 40, _hoisted_1$6)), [[vModelRadio, _ctx.inputValue]]);
}
script$h.render = render$h;
var script$g = defineComponent({
  name: "CheckboxField",
  props,
  emits,
  setup
});
var _hoisted_1$5 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === "error" ? `${_ctx.id}-error` : void 0,
    "aria-invalid": _ctx.errorMessage && _ctx.state === "error" ? true : void 0,
    name: _ctx.name,
    value: _ctx.value,
    type: "checkbox",
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
    onChange: _cache[2] || (_cache[2] = ($event) => _ctx.meta.touched = true)
  }, null, 40, _hoisted_1$5)), [[vModelCheckbox, _ctx.inputValue]]);
}
script$g.render = render$g;
var script$f = defineComponent({
  name: "InputError",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  setup() {
    const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
    const state = inject(injectionKeys.FORM.STATE);
    const id = inject(injectionKeys.FORM.ID);
    isMissingInjectable(errorMessage, state, id);
    return {
      errorMessage,
      state,
      id
    };
  }
});
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.errorMessage && _ctx.state === "error" ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: `${_ctx.id}-error`,
    "data-error": "true"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      errorMessage: _ctx.errorMessage
    }, () => [createTextVNode(toDisplayString(_ctx.errorMessage), 1)])]),
    _: 3
  }, 8, ["id"])) : createCommentVNode("", true);
}
script$f.render = render$f;
var script$e = defineComponent({
  name: "InputLabel",
  props: {
    text: {
      type: String,
      default: ""
    },
    legend: {
      type: Boolean,
      default: false
    },
    wrapper: {
      type: Boolean,
      default: false
    }
  },
  setup() {
    const inputId = inject(injectionKeys.FORM.ID);
    isMissingInjectable(inputId);
    return {
      inputId
    };
  }
});
function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.legend ? "legend" : "label"), {
    for: _ctx.wrapper ? null : !_ctx.legend ? _ctx.inputId : null
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.text), 1)])]),
    _: 3
  }, 8, ["for"]);
}
script$e.render = render$e;
function useHeadlessForm(props2, context) {
  const {
    handleSubmit,
    errors
  } = useForm();
  const triedToSubmit = ref(false);
  let sendErrorEvent = null;
  const onSubmit = handleSubmit((values) => {
    sendErrorEvent = false;
    context.emit("submitted", values);
  });
  async function submit(e) {
    sendErrorEvent = true;
    triedToSubmit.value = true;
    await onSubmit(e);
    if (sendErrorEvent) {
      context.emit("failed", errors.value);
      setTimeout(() => {
        let errorElement = document.querySelectorAll("[data-error]")[0];
        if (errorElement && props2.scrollToError) {
          let parentElement = errorElement.parentElement;
          let inputElement = null;
          while (parentElement !== null && inputElement === null) {
            if (parentElement.getAttribute("data-input")) {
              inputElement = parentElement;
            } else {
              parentElement = parentElement.parentElement;
            }
          }
          if (inputElement) {
            errorElement = inputElement;
          }
          errorElement.scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }
      }, 200);
    }
  }
  const errorCount = computed(() => !triedToSubmit.value ? 0 : Object.keys(errors.value).length);
  return {
    submit,
    errors,
    errorCount
  };
}
var script$d = defineComponent({
  name: "HeadlessForm",
  props: {
    scrollToError: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    submitted: null,
    failed: null
  },
  setup(props2, context) {
    const {
      submit,
      errors,
      errorCount
    } = useHeadlessForm(props2, context);
    return {
      submit,
      errors,
      errorCount
    };
  }
});
function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    onSubmit: _cache[0] || (_cache[0] = (...args) => _ctx.submit && _ctx.submit(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    errorCount: _ctx.errorCount,
    errors: _ctx.errors,
    submit: _ctx.submit
  })], 32);
}
script$d.render = render$d;
var script$c = defineComponent({
  name: "HeadlessAccordion",
  props: {
    modelValue: {
      type: Boolean,
      default: null
    },
    self: {
      type: Boolean,
      default: false
    },
    openByDefault: {
      type: Boolean,
      default: false
    },
    animationDelay: {
      type: Number,
      default: 700
    },
    as: {
      type: String,
      default: "div"
    },
    id: {
      type: [String, Number],
      default: null
    }
  },
  emits: {
    "update:modelValue": null
  },
  setup(props2, context) {
    const selfOpen = ref(!!props2.openByDefault);
    const accordionId = computed(() => {
      return props2.id ? `${props2.id}` : `accordion-${randomString()}`;
    });
    const delay = computed(() => props2.animationDelay);
    if (props2.openByDefault == true && props2.modelValue == false) {
      context.emit("update:modelValue", true);
    }
    const isOpen = computed({
      get: () => props2.self ? selfOpen.value : props2.modelValue,
      set: (newValue) => props2.self ? selfOpen.value = newValue : context.emit("update:modelValue", newValue)
    });
    function toggle() {
      isOpen.value = !isOpen.value;
    }
    provide(injectionKeys.ACCORDION.DELAY, delay);
    provide(injectionKeys.ACCORDION.IS_OPEN, isOpen);
    provide(injectionKeys.ACCORDION.TOGGLE, toggle);
    provide(injectionKeys.ACCORDION.COMPUTED_ID, accordionId);
    return {};
  }
});
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.as), null, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  });
}
script$c.render = render$c;
var script$b = defineComponent({
  name: "AccordionContentWrapper",
  emits: {
    mounted: null
  },
  setup(props2, {
    emit
  }) {
    const content = ref(null);
    onMounted(() => {
      if (content.value) {
        emit("mounted", content.value.scrollHeight);
      }
    });
    return {
      content
    };
  }
});
var _hoisted_1$4 = {
  ref: "content"
};
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [renderSlot(_ctx.$slots, "default")], 512);
}
script$b.render = render$b;
var script$a = defineComponent({
  components: {
    AccordionContentWrapper: script$b
  },
  name: "AccordionContent",
  setup() {
    const delay = inject(injectionKeys.ACCORDION.DELAY);
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(delay, isOpen, accordionId, toggle);
    const wrapper = ref(null);
    const visible = ref(!!(isOpen !== null && isOpen !== void 0 && isOpen.value));
    const height = ref(isOpen !== null && isOpen !== void 0 && isOpen.value ? null : 0);
    const overflow = ref("hidden");
    let zeroOutHeightTimeout = null;
    let setInvisibleTimeout = null;
    let setHeightAutoTimeout = null;
    function setHeightAuto() {
      height.value = null;
      overflow.value = "auto";
    }
    function setInvisible() {
      visible.value = false;
    }
    function setVisible() {
      visible.value = true;
    }
    function zeroOutHeight() {
      height.value = 0;
      overflow.value = "hidden";
      setInvisibleTimeout = setTimeout(setInvisible, delay === null || delay === void 0 ? void 0 : delay.value);
    }
    function contentMounted(scrollHeight) {
      height.value = scrollHeight;
      setHeightAutoTimeout = setTimeout(setHeightAuto, delay === null || delay === void 0 ? void 0 : delay.value);
    }
    watchEffect(() => {
      if (isOpen !== null && isOpen !== void 0 && isOpen.value) {
        var _wrapper$value;
        if (setInvisibleTimeout)
          clearTimeout(setInvisibleTimeout);
        if (zeroOutHeightTimeout)
          clearTimeout(zeroOutHeightTimeout);
        if ((_wrapper$value = wrapper.value) !== null && _wrapper$value !== void 0 && _wrapper$value.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        }
        setVisible();
      } else {
        var _wrapper$value2;
        if (setHeightAutoTimeout)
          clearTimeout(setHeightAutoTimeout);
        if ((_wrapper$value2 = wrapper.value) !== null && _wrapper$value2 !== void 0 && _wrapper$value2.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        }
        zeroOutHeightTimeout = setTimeout(zeroOutHeight, 20);
      }
    });
    return {
      isOpen,
      toggle,
      wrapper,
      height,
      overflow,
      visible,
      delay,
      accordionId,
      contentMounted
    };
  }
});
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_accordion_content_wrapper = resolveComponent("accordion-content-wrapper");
  return _ctx.visible ? (openBlock(), createBlock(_component_accordion_content_wrapper, {
    key: 0,
    id: _ctx.accordionId,
    ref: "wrapper",
    "aria-labelledby": `${_ctx.accordionId}_toggle`,
    style: normalizeStyle({
      height: _ctx.height != null ? `${_ctx.height}px` : "auto",
      overflow: _ctx.overflow,
      transition: `height ${_ctx.delay}ms`
    }),
    role: "region",
    onMounted: _ctx.contentMounted
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      open: _ctx.isOpen,
      toggle: _ctx.toggle
    })]),
    _: 3
  }, 8, ["id", "aria-labelledby", "style", "onMounted"])) : createCommentVNode("", true);
}
script$a.render = render$a;
var script$9 = defineComponent({
  name: "AccordionHeader",
  setup() {
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen,
      toggle,
      accordionId
    };
  }
});
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen,
    toggle: _ctx.toggle
  })]);
}
script$9.render = render$9;
var script$8 = defineComponent({
  name: "AccordionToggle",
  setup() {
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen,
      toggle,
      accordionId
    };
  }
});
var _hoisted_1$3 = ["id", "aria-controls", "aria-expanded"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    id: `${_ctx.accordionId}_toggle`,
    "aria-controls": _ctx.accordionId,
    "aria-expanded": _ctx.isOpen,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen
  })], 8, _hoisted_1$3);
}
script$8.render = render$8;
var script$7 = defineComponent({
  name: "HeadlessButton",
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  }
});
var _hoisted_1$2 = ["disabled", "aria-busy", "aria-live"];
var _hoisted_2 = {
  key: 0
};
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    disabled: _ctx.disabled || _ctx.loading,
    "aria-busy": _ctx.loading ? true : void 0,
    "aria-live": _ctx.loading ? "polite" : void 0
  }, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.label), 1)]), _ctx.loading ? (openBlock(), createElementBlock("span", _hoisted_2, [renderSlot(_ctx.$slots, "loading")])) : createCommentVNode("", true)], 8, _hoisted_1$2);
}
script$7.render = render$7;
var dialogs = ref([]);
function useDialogModel(props2, context) {
  const id = randomString();
  const value = computed({
    get: () => props2.modelValue,
    set: (newVal) => {
      if (newVal) {
        document.body.style.overflow = "hidden";
      }
      context.emit("update:modelValue", newVal);
    }
  });
  let activeElement = null;
  watch(value, () => {
    if (value.value) {
      dialogs.value.push(id);
      document.body.style.overflow = "hidden";
      if (document.activeElement) {
        activeElement = document.activeElement;
      }
    } else {
      dialogs.value = dialogs.value.filter((x) => x != id);
      if (dialogs.value.length == 0) {
        document.body.style.overflow = "";
      }
      if (activeElement) {
        activeElement.focus();
      }
    }
  });
  return {
    value,
    id
  };
}
var script$6 = defineComponent({
  name: "HeadlessDialog",
  props: {
    zIndex: {
      type: Number,
      default: 100
    },
    modelValue: {
      type: Boolean,
      default: null
    },
    fullScreen: {
      type: Boolean,
      default: false
    }
  },
  inheritAttrs: false,
  setup(props2, context) {
    const height = ref(window.innerHeight);
    const {
      value: isOpen,
      id
    } = useDialogModel(props2, context);
    provide(injectionKeys.DIALOG.ID, id);
    provide(injectionKeys.DIALOG.IS_OPEN, isOpen);
    function updateHeight() {
      height.value = window.innerHeight;
    }
    onMounted(() => {
      window.addEventListener("resize", updateHeight);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", updateHeight);
    });
    return {
      height,
      isOpen
    };
  }
});
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, {
    to: "body"
  }, [_ctx.isOpen ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    style: !_ctx.fullScreen ? {
      top: 0,
      left: 0,
      position: "fixed",
      width: "100vw",
      height: `${_ctx.height}px`,
      zIndex: _ctx.zIndex
    } : {}
  }, _ctx.$attrs), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true)]);
}
script$6.render = render$6;
var script$5 = defineComponent({
  name: "DomObserver",
  props: {
    config: {
      type: Object,
      default: () => {
        return {
          attributes: true,
          childList: true,
          subtree: true
        };
      }
    }
  },
  emits: {
    updated: null,
    mounted: null
  },
  setup(props2, context) {
    const content = ref(null);
    function callback() {
      context.emit("updated", content.value);
    }
    const observer = new MutationObserver(callback);
    onMounted(() => {
      if (content.value) {
        observer.observe(content.value, props2.config);
        context.emit("mounted", content.value);
      }
    });
    onBeforeMount(() => {
      observer.disconnect();
    });
    return {
      content
    };
  }
});
var _hoisted_1$1 = {
  ref: "content"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [renderSlot(_ctx.$slots, "default")], 512);
}
script$5.render = render$5;
var script$4 = defineComponent({
  components: {
    DomObserver: script$5
  },
  name: "DialogContent",
  setup() {
    const isOpen = inject(injectionKeys.DIALOG.IS_OPEN);
    const id = inject(injectionKeys.DIALOG.ID);
    isMissingInjectable(isOpen, id);
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    let focusableContent = null;
    function reloadDomArray(content) {
      focusableContent = content === null || content === void 0 ? void 0 : content.querySelectorAll(focusableElements);
      if (focusableContent) {
        let shouldResetFocus = true;
        for (let index = 0; index < focusableContent.length; index++) {
          const element = focusableContent[index];
          if (document.activeElement == element) {
            shouldResetFocus = false;
            break;
          }
        }
        if (focusableContent[0] && shouldResetFocus) {
          focusableContent[0].focus();
        }
      }
    }
    function onKeyDown(event) {
      if (dialogs.value[dialogs.value.length - 1] == id) {
        if (isOpen !== null && isOpen !== void 0 && isOpen.value && focusableContent) {
          const isTabPressed = event.key == "Tab";
          if (event.key == "Escape") {
            isOpen.value = false;
          }
          if (!isTabPressed) {
            return;
          }
          if (event.shiftKey) {
            if (document.activeElement === focusableContent[0]) {
              focusableContent[focusableContent.length - 1].focus();
              event.preventDefault();
            }
          } else {
            if (document.activeElement === focusableContent[focusableContent.length - 1]) {
              focusableContent[0].focus();
              event.preventDefault();
            }
          }
        }
      }
    }
    onMounted(() => {
      document.addEventListener("keydown", onKeyDown);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("keydown", onKeyDown);
    });
    return {
      reloadDomArray,
      id
    };
  }
});
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_dom_observer = resolveComponent("dom-observer");
  return openBlock(), createBlock(_component_dom_observer, {
    id: _ctx.id,
    "aria-modal": "true",
    onMounted: _ctx.reloadDomArray,
    onUpdated: _ctx.reloadDomArray
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["id", "onMounted", "onUpdated"]);
}
script$4.render = render$4;
var script$3 = defineComponent({
  name: "HeadlessTabs",
  props: {
    modelValue: {
      type: Number,
      default: null
    }
  },
  setup(props2, context) {
    const currentTab = useModel(props2, context);
    const tabs = ref([]);
    const switches = ref([]);
    function switchTab(index) {
      currentTab.value = index;
    }
    provide(injectionKeys.TABS.CURRENT_TAB, currentTab);
    provide(injectionKeys.TABS.TAB_ARRAY, tabs);
    provide(injectionKeys.TABS.SWITCH_ARRAY, switches);
    provide(injectionKeys.TABS.SWITCH_TAB, switchTab);
    return {
      currentTab,
      switchTab
    };
  }
});
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    switchTab: _ctx.switchTab
  })]);
}
script$3.render = render$3;
var script$2 = defineComponent({
  name: "HeadlessTab",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  setup() {
    const tabs = inject(injectionKeys.TABS.TAB_ARRAY);
    const switches = inject(injectionKeys.TABS.SWITCH_ARRAY, ref([]));
    const currentTab = inject(injectionKeys.TABS.CURRENT_TAB);
    const switchTab = inject(injectionKeys.TABS.SWITCH_TAB);
    isMissingInjectable(tabs, switches, currentTab, switchTab);
    const {
      id,
      index
    } = useArrayLink(tabs);
    return {
      currentTab,
      index,
      switchTab,
      id,
      switches
    };
  }
});
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.index === _ctx.currentTab ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: _ctx.id,
    "aria-labelledby": _ctx.switches[_ctx.index],
    role: "tabpanel"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      currentTab: _ctx.currentTab,
      switchTab: _ctx.switchTab,
      tabIndex: _ctx.index
    })]),
    _: 3
  }, 8, ["id", "aria-labelledby"])) : createCommentVNode("", true);
}
script$2.render = render$2;
var script$1 = defineComponent({
  name: "HeadlessTabSwitch",
  setup() {
    const switchButton = ref(null);
    const switches = inject(injectionKeys.TABS.SWITCH_ARRAY);
    const tabs = inject(injectionKeys.TABS.TAB_ARRAY, ref([]));
    const currentTab = inject(injectionKeys.TABS.CURRENT_TAB);
    const switchTab = inject(injectionKeys.TABS.SWITCH_TAB, () => {
    });
    isMissingInjectable(switches, currentTab);
    function onKeyDown(e) {
      if (currentTab && switches && switchTab) {
        switch (e.key) {
          case "ArrowRight":
            if (currentTab.value + 1 <= switches.value.length - 1) {
              switchTab(currentTab.value + 1);
            } else {
              switchTab(0);
            }
            break;
          case "ArrowLeft":
            if (currentTab.value - 1 >= 0) {
              switchTab(currentTab.value - 1);
            } else {
              switchTab(switches.value.length - 1);
            }
            break;
          case "Home":
            switchTab(0);
            break;
          case "End":
            switchTab(switches.value.length - 1);
            break;
        }
      }
    }
    const {
      id,
      index
    } = useArrayLink(switches);
    watchEffect(() => {
      if ((currentTab === null || currentTab === void 0 ? void 0 : currentTab.value) == index.value) {
        var _document$activeEleme;
        if (switchButton.value && ((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.getAttribute("role")) == "tab") {
          switchButton.value.focus();
        }
      }
    });
    return {
      currentTab,
      index,
      id,
      switchTab,
      onKeyDown,
      switchButton,
      tabs
    };
  }
});
var _hoisted_1 = ["id", "aria-controls", "aria-selected", "tabindex"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    id: _ctx.id,
    ref: "switchButton",
    "aria-controls": _ctx.tabs[_ctx.index],
    "aria-selected": _ctx.index === _ctx.currentTab,
    tabindex: _ctx.index !== _ctx.currentTab ? -1 : void 0,
    role: "tab",
    type: "button",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.switchTab(_ctx.index)),
    onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.onKeyDown && _ctx.onKeyDown(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    index: _ctx.index,
    switchTab: _ctx.switchTab
  })], 40, _hoisted_1);
}
script$1.render = render$1;
var script = defineComponent({
  name: "HeadlessTabSwitches",
  props: {
    ariaLabel: {
      type: [String, Number],
      default: "Tab list"
    },
    as: {
      type: String,
      default: "div"
    }
  },
  setup() {
  }
});
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    "aria-label": _ctx.ariaLabel,
    role: "tablist"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["aria-label"]);
}
script.render = render;
var components = Object.freeze({
  __proto__: null,
  HeadlessInput: script$l,
  InputField: script$k,
  TextareaField: script$j,
  SelectField: script$i,
  RadioField: script$h,
  CheckboxField: script$g,
  InputError: script$f,
  InputLabel: script$e,
  HeadlessForm: script$d,
  HeadlessAccordion: script$c,
  AccordionContent: script$a,
  AccordionHeader: script$9,
  AccordionToggle: script$8,
  HeadlessButton: script$7,
  HeadlessDialog: script$6,
  DialogContent: script$4,
  HeadlessTabs: script$3,
  HeadlessTab: script$2,
  HeadlessTabSwitch: script$1,
  HeadlessTabSwitches: script,
  DomObserver: script$5
});
var install = function installVueHeadlessUi(app) {
  Object.entries(components).forEach(([componentName, component]) => {
    app.component(componentName, component);
  });
};

// dep:vue-headless-ui
var vue_headless_ui_default = install;
export {
  script$a as AccordionContent,
  script$9 as AccordionHeader,
  script$8 as AccordionToggle,
  script$g as CheckboxField,
  script$4 as DialogContent,
  script$5 as DomObserver,
  script$c as HeadlessAccordion,
  script$7 as HeadlessButton,
  script$6 as HeadlessDialog,
  script$d as HeadlessForm,
  script$l as HeadlessInput,
  script$2 as HeadlessTab,
  script$1 as HeadlessTabSwitch,
  script as HeadlessTabSwitches,
  script$3 as HeadlessTabs,
  script$f as InputError,
  script$k as InputField,
  script$e as InputLabel,
  script$h as RadioField,
  script$i as SelectField,
  script$j as TextareaField,
  vue_headless_ui_default as default,
  injectionKeys,
  isMissingInjectable,
  randomString
};
/**
  * vee-validate v4.5.5
  * (c) 2021 Abdelrahman Awad
  * @license MIT
  */
//! This will still trigger the animation delay as of now because we are updating a proxy async and the initial state has been loaded already
//# sourceMappingURL=vue-headless-ui.js.map
