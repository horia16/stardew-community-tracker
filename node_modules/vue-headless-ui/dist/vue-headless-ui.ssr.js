'use strict';var vue=require('vue'),veeValidate=require('vee-validate');function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}/**
 * Create a random string
 */
function randomString() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
  return _toConsumableArray(Array(length)).map(function () {
    return Math.random().toString(36)[2];
  }).join("");
}/**
 * This function checks if any arguments are undefined and trows an error.
 */
function isMissingInjectable() {
  for (var index = 0; index < arguments.length; index++) {
    var element = index < 0 || arguments.length <= index ? undefined : arguments[index];

    if (element === undefined) {
      throw new Error("Missing injectable variable, please make sure you are using the correct wrapper component.");
    }
  }
}var ID$1 = Symbol("ID");
var INPUT_VALUE = Symbol("INPUT_VALUE");
var NAME = Symbol("NAME");
var ERROR_MESSAGE = Symbol("ERROR_MESSAGE");
var STATE = Symbol("STATE");
var VALIDATE = Symbol("VALIDATE");
var HANDLE_BLUR = Symbol("HANDLE_BLUR");
var META = Symbol("META");
var OPTIONS = Symbol("OPTIONS");
var INPUTS = Symbol("INPUTS");
var FORM = {
  ID: ID$1,
  INPUT_VALUE: INPUT_VALUE,
  OPTIONS: OPTIONS,
  NAME: NAME,
  ERROR_MESSAGE: ERROR_MESSAGE,
  STATE: STATE,
  VALIDATE: VALIDATE,
  HANDLE_BLUR: HANDLE_BLUR,
  META: META,
  INPUTS: INPUTS
};var ID = Symbol("ID");
var IS_OPEN$1 = Symbol("IS_OPEN");
var DIALOG = {
  ID: ID,
  IS_OPEN: IS_OPEN$1
};var IS_OPEN = Symbol("IS_OPEN");
var TOGGLE = Symbol("TOGGLE");
var COMPUTED_ID = Symbol("COMPUTED_ID");
var DELAY = Symbol("DELAY");
var ACCORDION = {
  IS_OPEN: IS_OPEN,
  TOGGLE: TOGGLE,
  COMPUTED_ID: COMPUTED_ID,
  DELAY: DELAY
};var TAB_ARRAY = Symbol("TAB_ARRAY");
var SWITCH_ARRAY = Symbol("SWITCH_ARRAY");
var CURRENT_TAB = Symbol("CURRENT_TAB");
var SWITCH_TAB = Symbol("SWITCH_TAB");
var TABS = {
  TAB_ARRAY: TAB_ARRAY,
  SWITCH_ARRAY: SWITCH_ARRAY,
  CURRENT_TAB: CURRENT_TAB,
  SWITCH_TAB: SWITCH_TAB
};var MATRIX = Symbol("MATRIX");
var UPDATE_DAY = Symbol("UPDATE_DAY");
var UPDATE_MONTH = Symbol("UPDATE_MONTH");
var UPDATE_YEAR = Symbol("UPDATE_YEAR");
var DATE_OBJECT = Symbol("DATE_OBJECT");
var START_SUNDAY = Symbol("START_SUNDAY");
var MODEL = Symbol("MODEL");
var LOCALE = Symbol("LOCALE");
var CALENDAR = {
  MATRIX: MATRIX,
  UPDATE_DAY: UPDATE_DAY,
  UPDATE_MONTH: UPDATE_MONTH,
  UPDATE_YEAR: UPDATE_YEAR,
  DATE_OBJECT: DATE_OBJECT,
  START_SUNDAY: START_SUNDAY,
  MODEL: MODEL,
  LOCALE: LOCALE
};var injectionKeys = {
  FORM: FORM,
  ACCORDION: ACCORDION,
  DIALOG: DIALOG,
  TABS: TABS,
  CALENDAR: CALENDAR
};var InputState;

(function (InputState) {
  InputState["Clear"] = "clear";
  InputState["Valid"] = "valid";
  InputState["Error"] = "error";
})(InputState || (InputState = {}));

/**
 * The minimal props required by an input type component
 */
var props$1 = {
  modelValue: {
    type: [String, Number, Boolean, Array, Object],
    default: null
  },
  options: {
    type: Array,
    default: null
  },
  id: {
    type: [String, Number],
    default: null
  },
  name: {
    type: [String, Number],
    default: null
  },
  rules: {
    type: [String, Function, Object],
    default: null
  },
  group: {
    type: Boolean,
    default: false
  },
  overrideState: {
    type: String,
    default: null
  }
};
/**
 * The minimal emits required by an input component
 */

var emits$1 = {
  blur: null,
  "update:modelValue": function updateModelValue(value) {
    if (value === undefined) {
      console.warn("Input context returned undefined value");
      return false;
    }

    return true;
  }
};
/**
 * A more complex version of the useField provided by vee-validate.
 * This takes care of a few extra things like auto id and name generation.
 */

function useFieldContext(props, context) {
  // Use the provided id otherwise generate a random one
  var inputId = props.id ? "".concat(props.id) : "input-".concat(randomString()); // Use the provided name or generate one based on the id

  var inputName = props.name ? "".concat(props.name) : "".concat(inputId, "-name"); // Use validation only if we don't have a parent state

  var _useField = veeValidate.useField(inputName, props.rules),
      errorMessage = _useField.errorMessage,
      value = _useField.value,
      meta = _useField.meta,
      validate = _useField.validate;

  var inputValue = vue.computed({
    get: function get() {
      return props.modelValue;
    },
    set: function set(val) {
      // Emit our new value
      context.emit("update:modelValue", val);
    }
  });
  vue.watch(inputValue, function (newVal) {
    // Update the vee-validate value
    value.value = newVal;
  });
  /**
   * The state of our input value
   */

  var state = vue.computed(function () {
    if (props.overrideState != null) {
      return props.overrideState;
    }

    if (meta.touched && meta.validated) {
      if (meta.valid) {
        return InputState.Valid;
      }

      return InputState.Error;
    }

    return InputState.Clear;
  });
  /**
   * Handle the onblur event emitted by the input
   */

  function handleBlur() {
    return _handleBlur.apply(this, arguments);
  } // If we already have a value upon entry


  function _handleBlur() {
    _handleBlur = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              meta.touched = true;

              if (!(props.overrideState == null)) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return validate();

            case 4:
              // Emit it further to the parent component
              context.emit("blur");

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _handleBlur.apply(this, arguments);
  }

  if (props.modelValue) {
    // Update that in vee-validate
    value.value = props.modelValue; // Different scenario when the value is an array as we don't want to validate empty arrays upon creation

    if (Array.isArray(value.value)) {
      if (value.value.length > 0) {
        meta.touched = true;
        validate().catch(function (error) {
          console.warn(error);
        });
      }
    } else {
      meta.touched = true;
      validate().catch(function (error) {
        console.warn(error);
      });
    }
  }

  return {
    errorMessage: errorMessage,
    inputValue: inputValue,
    inputName: inputName,
    inputId: inputId,
    meta: meta,
    state: state,
    validate: validate,
    handleBlur: handleBlur
  };
}
/**
 * Simple model wrapper for the vue v-model directive.
 */

function useModel(props, context) {
  return vue.computed({
    get: function get() {
      return props.modelValue;
    },
    set: function set(val) {
      context.emit("update:modelValue", val);
    }
  });
}var script$l = vue.defineComponent({
  name: "HeadlessInput",
  props: props$1,
  emits: emits$1,
  setup: function setup(props, context) {
    var _useFieldContext = useFieldContext(props, context),
        errorMessage = _useFieldContext.errorMessage,
        inputValue = _useFieldContext.inputValue,
        inputName = _useFieldContext.inputName,
        inputId = _useFieldContext.inputId,
        state = _useFieldContext.state,
        validate = _useFieldContext.validate,
        handleBlur = _useFieldContext.handleBlur,
        meta = _useFieldContext.meta;

    var thing = [];
    var inputs = vue.ref([]);
    vue.provide(injectionKeys.FORM.ID, inputId);
    vue.provide(injectionKeys.FORM.INPUT_VALUE, inputValue);
    vue.provide(injectionKeys.FORM.NAME, inputName);
    vue.provide(injectionKeys.FORM.ERROR_MESSAGE, errorMessage);
    vue.provide(injectionKeys.FORM.STATE, state);
    vue.provide(injectionKeys.FORM.VALIDATE, validate);
    vue.provide(injectionKeys.FORM.HANDLE_BLUR, handleBlur);
    vue.provide(injectionKeys.FORM.META, meta);
    vue.provide(injectionKeys.FORM.OPTIONS, props.options);
    vue.provide(injectionKeys.FORM.INPUTS, inputs);
    return {
      errorMessage: errorMessage,
      state: state,
      validate: validate,
      handleBlur: handleBlur,
      meta: meta,
      inputs: inputs,
      thing: thing
    };
  }
});function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.group ? 'fieldset' : 'div'), {
    "data-input": "true"
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {
        errorMessage: _ctx.errorMessage,
        handleBlur: _ctx.handleBlur,
        meta: _ctx.meta,
        state: _ctx.state,
        validate: _ctx.validate
      })];
    }),
    _: 3
  });
}script$l.render = render$l;var emits = {
  blur: null
};
function setup$1() {
  var inputValue = vue.inject(injectionKeys.FORM.INPUT_VALUE);
  var id = vue.inject(injectionKeys.FORM.ID);
  var name = vue.inject(injectionKeys.FORM.NAME);
  var errorMessage = vue.inject(injectionKeys.FORM.ERROR_MESSAGE);
  var state = vue.inject(injectionKeys.FORM.STATE);
  var handleBlur = vue.inject(injectionKeys.FORM.HANDLE_BLUR);
  isMissingInjectable(id, name, errorMessage, state, handleBlur);
  return {
    inputValue: inputValue,
    id: id,
    name: name,
    handleBlur: handleBlur,
    errorMessage: errorMessage,
    state: state
  };
}var script$k = vue.defineComponent({
  name: "InputField",
  emits: emits,
  setup: setup$1
});var _hoisted_1$9 = ["id", "aria-describedby", "aria-invalid", "name"];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return _ctx.inputValue = $event;
    }),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? "".concat(_ctx.id, "-error") : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    onBlur: _cache[1] || (_cache[1] = function () {
      return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
    })
  }, null, 40, _hoisted_1$9)), [[vue.vModelText, _ctx.inputValue]]);
}script$k.render = render$k;var script$j = vue.defineComponent({
  name: "TextareaField",
  emits: emits,
  setup: setup$1
});var _hoisted_1$8 = ["id", "aria-describedby", "aria-invalid"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("textarea", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return _ctx.inputValue = $event;
    }),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? "".concat(_ctx.id, "-error") : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    onBlur: _cache[1] || (_cache[1] = function () {
      return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
    })
  }, null, 40, _hoisted_1$8)), [[vue.vModelText, _ctx.inputValue]]);
}script$j.render = render$j;var script$i = vue.defineComponent({
  name: "SelectField",
  props: {
    placeholder: {
      type: String,
      default: null
    },
    valueKey: {
      type: String,
      default: "value"
    },
    nameKey: {
      type: String,
      default: "name"
    }
  },
  emits: emits,
  setup: function setup() {
    var inputValue = vue.inject(injectionKeys.FORM.INPUT_VALUE);
    var id = vue.inject(injectionKeys.FORM.ID);
    var name = vue.inject(injectionKeys.FORM.NAME);
    var handleBlur = vue.inject(injectionKeys.FORM.HANDLE_BLUR);
    var options = vue.inject(injectionKeys.FORM.OPTIONS);
    if (!options) console.warn("Missing options. Please make sure are passing options to the headless input.");
    isMissingInjectable(id, inputValue, name, handleBlur, options);
    return {
      inputValue: inputValue,
      id: id,
      handleBlur: handleBlur,
      options: options
    };
  }
});var _hoisted_1$7 = ["id"];
var _hoisted_2$1 = {
  key: 0,
  value: null,
  disabled: "",
  hidden: "",
  selected: ""
};
var _hoisted_3 = ["value"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("select", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return _ctx.inputValue = $event;
    }),
    onBlur: _cache[1] || (_cache[1] = function () {
      return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
    })
  }, [_ctx.placeholder ? (vue.openBlock(), vue.createElementBlock("option", _hoisted_2$1, vue.toDisplayString(_ctx.placeholder), 1)) : vue.createCommentVNode("", true), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option, index) {
    return vue.openBlock(), vue.createElementBlock("option", {
      key: index,
      value: option[_ctx.valueKey]
    }, vue.toDisplayString(option[_ctx.nameKey]), 9, _hoisted_3);
  }), 128))], 40, _hoisted_1$7)), [[vue.vModelSelect, _ctx.inputValue]]);
}script$i.render = render$i;/**
 * Link a component to a given Ref Array, creating an unique id and the necessary events.
 * @param array
 */

function useArrayLink(array) {
  // Create a random id
  var id = vue.ref(randomString()); // If we do not have that id push it to the array

  if (!(array !== null && array !== void 0 && array.value.find(function (x) {
    return x === id.value;
  })) && id.value) {
    array === null || array === void 0 ? void 0 : array.value.push(id.value);
  } // Get the index of element


  var index = vue.computed(function () {
    if (array) {
      var _index = array.value.findIndex(function (x) {
        return x == id.value;
      });

      if (_index != null || _index != undefined) {
        return _index;
      }

      return -1;
    }

    return -1;
  }); // Make sure we remove the element from the array in case we unmount it

  vue.onBeforeUnmount(function () {
    if (array) array.value = array.value.filter(function (x) {
      return x != id.value;
    });
  });
  return {
    id: id,
    index: index
  };
}var props = {
  value: {
    type: [String, Number, Object, Array],
    default: null
  }
};
function setup() {
  var inputValue = vue.inject(injectionKeys.FORM.INPUT_VALUE);
  var id = vue.inject(injectionKeys.FORM.ID);
  var name = vue.inject(injectionKeys.FORM.NAME);
  var errorMessage = vue.inject(injectionKeys.FORM.ERROR_MESSAGE);
  var state = vue.inject(injectionKeys.FORM.STATE);
  var meta = vue.inject(injectionKeys.FORM.META, {
    touched: false,
    dirty: false,
    valid: false,
    validated: false,
    pending: false,
    initialValue: null
  });
  var handleBlur = vue.inject(injectionKeys.FORM.HANDLE_BLUR);
  var inputs = vue.inject(injectionKeys.FORM.INPUTS);
  isMissingInjectable(id, inputValue, name, errorMessage, state, handleBlur, inputs);

  var _useArrayLink = useArrayLink(inputs),
      inputId = _useArrayLink.id;

  return {
    inputValue: inputValue,
    id: id,
    inputId: inputId,
    name: name,
    handleBlur: handleBlur,
    errorMessage: errorMessage,
    state: state,
    meta: meta
  };
}var script$h = vue.defineComponent({
  name: "RadioField",
  props: props,
  emits: emits,
  setup: setup
});var _hoisted_1$6 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return _ctx.inputValue = $event;
    }),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? "".concat(_ctx.id, "-error") : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    value: _ctx.value,
    type: "radio",
    onBlur: _cache[1] || (_cache[1] = function () {
      return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function ($event) {
      return _ctx.meta.touched = true;
    })
  }, null, 40, _hoisted_1$6)), [[vue.vModelRadio, _ctx.inputValue]]);
}script$h.render = render$h;var script$g = vue.defineComponent({
  name: "CheckboxField",
  props: props,
  emits: emits,
  setup: setup
});var _hoisted_1$5 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
      return _ctx.inputValue = $event;
    }),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? "".concat(_ctx.id, "-error") : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    value: _ctx.value,
    type: "checkbox",
    onBlur: _cache[1] || (_cache[1] = function () {
      return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
    }),
    onChange: _cache[2] || (_cache[2] = function ($event) {
      return _ctx.meta.touched = true;
    })
  }, null, 40, _hoisted_1$5)), [[vue.vModelCheckbox, _ctx.inputValue]]);
}script$g.render = render$g;var script$f = vue.defineComponent({
  name: "InputError",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  setup: function setup() {
    var errorMessage = vue.inject(injectionKeys.FORM.ERROR_MESSAGE);
    var state = vue.inject(injectionKeys.FORM.STATE);
    var id = vue.inject(injectionKeys.FORM.ID);
    isMissingInjectable(errorMessage, state, id);
    return {
      errorMessage: errorMessage,
      state: state,
      id: id
    };
  }
});function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.errorMessage && _ctx.state === 'error' ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: "".concat(_ctx.id, "-error"),
    "data-error": "true"
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {
        errorMessage: _ctx.errorMessage
      }, function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.errorMessage), 1)];
      })];
    }),
    _: 3
  }, 8, ["id"])) : vue.createCommentVNode("", true);
}script$f.render = render$f;var script$e = vue.defineComponent({
  name: "InputLabel",
  props: {
    text: {
      type: String,
      default: ""
    },
    legend: {
      type: Boolean,
      default: false
    },
    wrapper: {
      type: Boolean,
      default: false
    }
  },
  setup: function setup() {
    var inputId = vue.inject(injectionKeys.FORM.ID);
    isMissingInjectable(inputId);
    return {
      inputId: inputId
    };
  }
});function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.legend ? 'legend' : 'label'), {
    for: _ctx.wrapper ? null : !_ctx.legend ? _ctx.inputId : null
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {}, function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.text), 1)];
      })];
    }),
    _: 3
  }, 8, ["for"]);
}script$e.render = render$e;function useHeadlessForm(props, context) {
  var _useForm = veeValidate.useForm(),
      handleSubmit = _useForm.handleSubmit,
      errors = _useForm.errors;

  var triedToSubmit = vue.ref(false);
  var sendErrorEvent = null;
  var onSubmit = handleSubmit(function (values) {
    sendErrorEvent = false;
    context.emit("submitted", values);
  });

  function submit(_x) {
    return _submit.apply(this, arguments);
  }

  function _submit() {
    _submit = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              sendErrorEvent = true;
              triedToSubmit.value = true;
              _context.next = 4;
              return onSubmit(e);

            case 4:
              if (sendErrorEvent) {
                context.emit("failed", errors.value);
                setTimeout(function () {
                  // Get the first error in the document
                  var errorElement = document.querySelectorAll("[data-error]")[0];

                  if (errorElement && props.scrollToError) {
                    var parentElement = errorElement.parentElement;
                    var inputElement = null; // Try and extract the input element

                    while (parentElement !== null && inputElement === null) {
                      if (parentElement.getAttribute("data-input")) {
                        inputElement = parentElement;
                      } else {
                        parentElement = parentElement.parentElement;
                      }
                    }

                    if (inputElement) {
                      errorElement = inputElement;
                    }

                    errorElement.scrollIntoView({
                      behavior: "smooth",
                      block: "center"
                    });
                  }
                }, 200);
              }

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _submit.apply(this, arguments);
  }

  var errorCount = vue.computed(function () {
    return !triedToSubmit.value ? 0 : Object.keys(errors.value).length;
  });
  return {
    submit: submit,
    errors: errors,
    errorCount: errorCount
  };
}var script$d = vue.defineComponent({
  name: "HeadlessForm",
  props: {
    scrollToError: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    submitted: null,
    failed: null
  },
  setup: function setup(props, context) {
    var _useHeadlessForm = useHeadlessForm(props, context),
        submit = _useHeadlessForm.submit,
        errors = _useHeadlessForm.errors,
        errorCount = _useHeadlessForm.errorCount;

    return {
      submit: submit,
      errors: errors,
      errorCount: errorCount
    };
  }
});function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("form", {
    onSubmit: _cache[0] || (_cache[0] = function () {
      return _ctx.submit && _ctx.submit.apply(_ctx, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "default", {
    errorCount: _ctx.errorCount,
    errors: _ctx.errors,
    submit: _ctx.submit
  })], 32);
}script$d.render = render$d;var script$c = vue.defineComponent({
  name: "HeadlessAccordion",
  props: {
    modelValue: {
      type: Boolean,
      default: null
    },
    self: {
      type: Boolean,
      default: false
    },
    openByDefault: {
      type: Boolean,
      default: false
    },
    animationDelay: {
      type: Number,
      default: 700
    },
    as: {
      type: String,
      default: "div"
    },
    id: {
      type: [String, Number],
      default: null
    }
  },
  emits: {
    "update:modelValue": null
  },
  setup: function setup(props, context) {
    var selfOpen = vue.ref(!!props.openByDefault);
    var accordionId = vue.computed(function () {
      return props.id ? "".concat(props.id) : "accordion-".concat(randomString());
    });
    var delay = vue.computed(function () {
      return props.animationDelay;
    }); // If we are open by default and the v-model is set to false make it true
    //! This will still trigger the animation delay as of now because we are updating a proxy async and the initial state has been loaded already

    if (props.openByDefault == true && props.modelValue == false) {
      context.emit("update:modelValue", true);
    }

    var isOpen = vue.computed({
      get: function get() {
        return props.self ? selfOpen.value : props.modelValue;
      },
      set: function set(newValue) {
        return props.self ? selfOpen.value = newValue : context.emit("update:modelValue", newValue);
      }
    });

    function toggle() {
      isOpen.value = !isOpen.value;
    }

    vue.provide(injectionKeys.ACCORDION.DELAY, delay);
    vue.provide(injectionKeys.ACCORDION.IS_OPEN, isOpen);
    vue.provide(injectionKeys.ACCORDION.TOGGLE, toggle);
    vue.provide(injectionKeys.ACCORDION.COMPUTED_ID, accordionId);
    return {};
  }
});function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.as), null, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  });
}script$c.render = render$c;var script$b = vue.defineComponent({
  name: "AccordionContentWrapper",
  emits: {
    mounted: null
  },
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    var content = vue.ref(null);
    vue.onMounted(function () {
      if (content.value) {
        emit("mounted", content.value.scrollHeight);
      }
    });
    return {
      content: content
    };
  }
});var _hoisted_1$4 = {
  ref: "content"
};
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [vue.renderSlot(_ctx.$slots, "default")], 512);
}script$b.render = render$b;var script$a = vue.defineComponent({
  components: {
    AccordionContentWrapper: script$b
  },
  name: "AccordionContent",
  setup: function setup() {
    var delay = vue.inject(injectionKeys.ACCORDION.DELAY);
    var isOpen = vue.inject(injectionKeys.ACCORDION.IS_OPEN);
    var accordionId = vue.inject(injectionKeys.ACCORDION.COMPUTED_ID);
    var toggle = vue.inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(delay, isOpen, accordionId, toggle);
    var wrapper = vue.ref(null);
    var visible = vue.ref(!!(isOpen !== null && isOpen !== void 0 && isOpen.value));
    var height = vue.ref(isOpen !== null && isOpen !== void 0 && isOpen.value ? null : 0);
    var overflow = vue.ref("hidden"); // eslint-disable-next-line no-undef

    var zeroOutHeightTimeout = null; // eslint-disable-next-line no-undef

    var setInvisibleTimeout = null; // eslint-disable-next-line no-undef

    var setHeightAutoTimeout = null;

    function setHeightAuto() {
      height.value = null; // Set the overflow to auto when the accordion is fully expanded.

      overflow.value = "auto";
    }

    function setInvisible() {
      visible.value = false;
    }

    function setVisible() {
      visible.value = true;
    }

    function zeroOutHeight() {
      height.value = 0;
      overflow.value = "hidden"; // Remove the content completely from the dom after the animation has been completed.

      setInvisibleTimeout = setTimeout(setInvisible, delay === null || delay === void 0 ? void 0 : delay.value);
    }

    function contentMounted(scrollHeight) {
      height.value = scrollHeight; // Set the height to auto after the animation has been finished.

      setHeightAutoTimeout = setTimeout(setHeightAuto, delay === null || delay === void 0 ? void 0 : delay.value);
    }

    vue.watchEffect(function () {
      // We are opening the accordion
      if (isOpen !== null && isOpen !== void 0 && isOpen.value) {
        var _wrapper$value;

        // If we have any timeout set for closing the accordion, i.e. opening it while the closing animation did not finish,  clear them
        if (setInvisibleTimeout) clearTimeout(setInvisibleTimeout);
        if (zeroOutHeightTimeout) clearTimeout(zeroOutHeightTimeout); // If the content wrapper is mounted already, get the height

        if ((_wrapper$value = wrapper.value) !== null && _wrapper$value !== void 0 && _wrapper$value.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        } // Set the visibility of the content to true


        setVisible();
      } else {
        var _wrapper$value2;

        // If we have any timeout set for opening the accordion, clear it
        if (setHeightAutoTimeout) clearTimeout(setHeightAutoTimeout); // If we have a wrapper set from height auto to the height of the wrapper so we can get a nice transition

        if ((_wrapper$value2 = wrapper.value) !== null && _wrapper$value2 !== void 0 && _wrapper$value2.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        } // Set the height to 0 after 20 ms so the css engine will play the transition


        zeroOutHeightTimeout = setTimeout(zeroOutHeight, 20);
      }
    });
    return {
      isOpen: isOpen,
      toggle: toggle,
      wrapper: wrapper,
      height: height,
      overflow: overflow,
      visible: visible,
      delay: delay,
      accordionId: accordionId,
      contentMounted: contentMounted
    };
  }
});function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_accordion_content_wrapper = vue.resolveComponent("accordion-content-wrapper");

  return _ctx.visible ? (vue.openBlock(), vue.createBlock(_component_accordion_content_wrapper, {
    key: 0,
    id: _ctx.accordionId,
    ref: "wrapper",
    "aria-labelledby": "".concat(_ctx.accordionId, "_toggle"),
    style: vue.normalizeStyle({
      height: _ctx.height != null ? "".concat(_ctx.height, "px") : 'auto',
      overflow: _ctx.overflow,
      transition: "height ".concat(_ctx.delay, "ms")
    }),
    role: "region",
    onMounted: _ctx.contentMounted
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {
        open: _ctx.isOpen,
        toggle: _ctx.toggle
      })];
    }),
    _: 3
  }, 8, ["id", "aria-labelledby", "style", "onMounted"])) : vue.createCommentVNode("", true);
}script$a.render = render$a;var script$9 = vue.defineComponent({
  name: "AccordionHeader",
  setup: function setup() {
    var isOpen = vue.inject(injectionKeys.ACCORDION.IS_OPEN);
    var accordionId = vue.inject(injectionKeys.ACCORDION.COMPUTED_ID);
    var toggle = vue.inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen: isOpen,
      toggle: toggle,
      accordionId: accordionId
    };
  }
});function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", null, [vue.renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen,
    toggle: _ctx.toggle
  })]);
}script$9.render = render$9;var script$8 = vue.defineComponent({
  name: "AccordionToggle",
  setup: function setup() {
    var isOpen = vue.inject(injectionKeys.ACCORDION.IS_OPEN);
    var accordionId = vue.inject(injectionKeys.ACCORDION.COMPUTED_ID);
    var toggle = vue.inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen: isOpen,
      toggle: toggle,
      accordionId: accordionId
    };
  }
});var _hoisted_1$3 = ["id", "aria-controls", "aria-expanded"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("button", {
    id: "".concat(_ctx.accordionId, "_toggle"),
    "aria-controls": _ctx.accordionId,
    "aria-expanded": _ctx.isOpen,
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.toggle && _ctx.toggle.apply(_ctx, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen
  })], 8, _hoisted_1$3);
}script$8.render = render$8;var script$7 = vue.defineComponent({
  name: "HeadlessButton",
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  }
});var _hoisted_1$2 = ["disabled", "aria-busy", "aria-live"];
var _hoisted_2 = {
  key: 0
};
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("button", {
    disabled: _ctx.disabled || _ctx.loading,
    "aria-busy": _ctx.loading ? true : undefined,
    "aria-live": _ctx.loading ? 'polite' : undefined
  }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
    return [vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)];
  }), _ctx.loading ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2, [vue.renderSlot(_ctx.$slots, "loading")])) : vue.createCommentVNode("", true)], 8, _hoisted_1$2);
}script$7.render = render$7;var dialogs = vue.ref([]);
function useDialogModel(props, context) {
  /**
   * Random dialog id.
   */
  var id = randomString();
  var value = vue.computed({
    get: function get() {
      return props.modelValue;
    },
    set: function set(newVal) {
      if (newVal) {
        document.body.style.overflow = "hidden";
      }

      context.emit("update:modelValue", newVal);
    }
  });
  var activeElement = null;
  vue.watch(value, function () {
    if (value.value) {
      // We are opening the dialog so push it to the dialogs array
      dialogs.value.push(id); // Make sure we hide the scroll on the body

      document.body.style.overflow = "hidden"; // When we open the modal keep the element that we were focused on in memory

      if (document.activeElement) {
        activeElement = document.activeElement;
      }
    } else {
      // Closing the dialog so remove it from the array. It should always be on top for nested dialogs.
      dialogs.value = dialogs.value.filter(function (x) {
        return x != id;
      }); // If we have note left remove the overflow from the body

      if (dialogs.value.length == 0) {
        document.body.style.overflow = "";
      } // Focus back on the element that we were focused on prior to opening the modal


      if (activeElement) {
        activeElement.focus();
      }
    }
  });
  return {
    value: value,
    id: id
  };
}var script$6 = vue.defineComponent({
  name: "HeadlessDialog",
  props: {
    zIndex: {
      type: Number,
      default: 100
    },
    modelValue: {
      type: Boolean,
      default: null
    },
    fullScreen: {
      type: Boolean,
      default: false
    }
  },
  inheritAttrs: false,
  setup: function setup(props, context) {
    var height = vue.ref(window.innerHeight);

    var _useDialogModel = useDialogModel(props, context),
        isOpen = _useDialogModel.value,
        id = _useDialogModel.id;

    vue.provide(injectionKeys.DIALOG.ID, id);
    vue.provide(injectionKeys.DIALOG.IS_OPEN, isOpen);

    function updateHeight() {
      height.value = window.innerHeight;
    }

    vue.onMounted(function () {
      window.addEventListener("resize", updateHeight);
    });
    vue.onBeforeUnmount(function () {
      window.removeEventListener("resize", updateHeight);
    });
    return {
      height: height,
      isOpen: isOpen
    };
  }
});function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.Teleport, {
    to: "body"
  }, [_ctx.isOpen ? (vue.openBlock(), vue.createElementBlock("div", vue.mergeProps({
    key: 0,
    style: !_ctx.fullScreen ? {
      top: 0,
      left: 0,
      position: 'fixed',
      width: '100vw',
      height: "".concat(_ctx.height, "px"),
      zIndex: _ctx.zIndex
    } : {}
  }, _ctx.$attrs), [vue.renderSlot(_ctx.$slots, "default")], 16)) : vue.createCommentVNode("", true)]);
}script$6.render = render$6;var script$5 = vue.defineComponent({
  name: "DomObserver",
  props: {
    config: {
      type: Object,
      default: function _default() {
        return {
          attributes: true,
          childList: true,
          subtree: true
        };
      }
    }
  },
  emits: {
    updated: null,
    mounted: null
  },
  setup: function setup(props, context) {
    var content = vue.ref(null);

    function callback() {
      context.emit("updated", content.value);
    }

    var observer = new MutationObserver(callback);
    vue.onMounted(function () {
      if (content.value) {
        observer.observe(content.value, props.config);
        context.emit("mounted", content.value);
      }
    });
    vue.onBeforeMount(function () {
      observer.disconnect();
    });
    return {
      content: content
    };
  }
});var _hoisted_1$1 = {
  ref: "content"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [vue.renderSlot(_ctx.$slots, "default")], 512);
}script$5.render = render$5;var script$4 = vue.defineComponent({
  components: {
    DomObserver: script$5
  },
  name: "DialogContent",
  setup: function setup() {
    var isOpen = vue.inject(injectionKeys.DIALOG.IS_OPEN);
    var id = vue.inject(injectionKeys.DIALOG.ID);
    isMissingInjectable(isOpen, id);
    var focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    var focusableContent = null;

    function reloadDomArray(content) {
      focusableContent = content === null || content === void 0 ? void 0 : content.querySelectorAll(focusableElements); // If we are already focused on an element form this array we should not not reset the focus.

      if (focusableContent) {
        var shouldResetFocus = true;

        for (var index = 0; index < focusableContent.length; index++) {
          var element = focusableContent[index];

          if (document.activeElement == element) {
            shouldResetFocus = false;
            break;
          }
        }

        if (focusableContent[0] && shouldResetFocus) {
          // Focus on the first available element
          focusableContent[0].focus();
        }
      }
    }

    function onKeyDown(event) {
      // If the last active dialog is this
      if (dialogs.value[dialogs.value.length - 1] == id) {
        if (isOpen !== null && isOpen !== void 0 && isOpen.value && focusableContent) {
          var isTabPressed = event.key == "Tab";

          if (event.key == "Escape") {
            isOpen.value = false;
          }

          if (!isTabPressed) {
            return;
          }

          if (event.shiftKey) {
            if (document.activeElement === focusableContent[0]) {
              focusableContent[focusableContent.length - 1].focus();
              event.preventDefault();
            }
          } else {
            if (document.activeElement === focusableContent[focusableContent.length - 1]) {
              focusableContent[0].focus();
              event.preventDefault();
            }
          }
        }
      }
    }

    vue.onMounted(function () {
      document.addEventListener("keydown", onKeyDown);
    });
    vue.onBeforeUnmount(function () {
      document.removeEventListener("keydown", onKeyDown);
    });
    return {
      reloadDomArray: reloadDomArray,
      id: id
    };
  }
});function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_dom_observer = vue.resolveComponent("dom-observer");

  return vue.openBlock(), vue.createBlock(_component_dom_observer, {
    id: _ctx.id,
    "aria-modal": "true",
    onMounted: _ctx.reloadDomArray,
    onUpdated: _ctx.reloadDomArray
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 8, ["id", "onMounted", "onUpdated"]);
}script$4.render = render$4;var script$3 = vue.defineComponent({
  name: "HeadlessTabs",
  props: {
    modelValue: {
      type: Number,
      default: null
    }
  },
  setup: function setup(props, context) {
    var currentTab = useModel(props, context);
    var tabs = vue.ref([]);
    var switches = vue.ref([]);

    function switchTab(index) {
      currentTab.value = index;
    }

    vue.provide(injectionKeys.TABS.CURRENT_TAB, currentTab);
    vue.provide(injectionKeys.TABS.TAB_ARRAY, tabs);
    vue.provide(injectionKeys.TABS.SWITCH_ARRAY, switches);
    vue.provide(injectionKeys.TABS.SWITCH_TAB, switchTab);
    return {
      currentTab: currentTab,
      switchTab: switchTab
    };
  }
});function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", null, [vue.renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    switchTab: _ctx.switchTab
  })]);
}script$3.render = render$3;var script$2 = vue.defineComponent({
  name: "HeadlessTab",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  setup: function setup() {
    var tabs = vue.inject(injectionKeys.TABS.TAB_ARRAY);
    var switches = vue.inject(injectionKeys.TABS.SWITCH_ARRAY, vue.ref([]));
    var currentTab = vue.inject(injectionKeys.TABS.CURRENT_TAB);
    var switchTab = vue.inject(injectionKeys.TABS.SWITCH_TAB);
    isMissingInjectable(tabs, switches, currentTab, switchTab);

    var _useArrayLink = useArrayLink(tabs),
        id = _useArrayLink.id,
        index = _useArrayLink.index;

    return {
      currentTab: currentTab,
      index: index,
      switchTab: switchTab,
      id: id,
      switches: switches
    };
  }
});function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.index === _ctx.currentTab ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: _ctx.id,
    "aria-labelledby": _ctx.switches[_ctx.index],
    role: "tabpanel"
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default", {
        currentTab: _ctx.currentTab,
        switchTab: _ctx.switchTab,
        tabIndex: _ctx.index
      })];
    }),
    _: 3
  }, 8, ["id", "aria-labelledby"])) : vue.createCommentVNode("", true);
}script$2.render = render$2;var script$1 = vue.defineComponent({
  name: "HeadlessTabSwitch",
  setup: function setup() {
    var switchButton = vue.ref(null);
    var switches = vue.inject(injectionKeys.TABS.SWITCH_ARRAY);
    var tabs = vue.inject(injectionKeys.TABS.TAB_ARRAY, vue.ref([]));
    var currentTab = vue.inject(injectionKeys.TABS.CURRENT_TAB);
    var switchTab = vue.inject(injectionKeys.TABS.SWITCH_TAB, function () {});
    isMissingInjectable(switches, currentTab);

    function onKeyDown(e) {
      if (currentTab && switches && switchTab) {
        switch (e.key) {
          case "ArrowRight":
            if (currentTab.value + 1 <= switches.value.length - 1) {
              switchTab(currentTab.value + 1);
            } else {
              switchTab(0);
            }

            break;

          case "ArrowLeft":
            if (currentTab.value - 1 >= 0) {
              switchTab(currentTab.value - 1);
            } else {
              switchTab(switches.value.length - 1);
            }

            break;

          case "Home":
            switchTab(0);
            break;

          case "End":
            switchTab(switches.value.length - 1);
            break;
        }
      }
    }

    var _useArrayLink = useArrayLink(switches),
        id = _useArrayLink.id,
        index = _useArrayLink.index;

    vue.watchEffect(function () {
      if ((currentTab === null || currentTab === void 0 ? void 0 : currentTab.value) == index.value) {
        var _document$activeEleme;

        // Get the focus only if we move from another tab button
        if (switchButton.value && ((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.getAttribute("role")) == "tab") {
          switchButton.value.focus();
        }
      }
    });
    return {
      currentTab: currentTab,
      index: index,
      id: id,
      switchTab: switchTab,
      onKeyDown: onKeyDown,
      switchButton: switchButton,
      tabs: tabs
    };
  }
});var _hoisted_1 = ["id", "aria-controls", "aria-selected", "tabindex"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("button", {
    id: _ctx.id,
    ref: "switchButton",
    "aria-controls": _ctx.tabs[_ctx.index],
    "aria-selected": _ctx.index === _ctx.currentTab,
    tabindex: _ctx.index !== _ctx.currentTab ? -1 : undefined,
    role: "tab",
    type: "button",
    onClick: _cache[0] || (_cache[0] = function ($event) {
      return _ctx.switchTab(_ctx.index);
    }),
    onKeydown: _cache[1] || (_cache[1] = function () {
      return _ctx.onKeyDown && _ctx.onKeyDown.apply(_ctx, arguments);
    })
  }, [vue.renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    index: _ctx.index,
    switchTab: _ctx.switchTab
  })], 40, _hoisted_1);
}script$1.render = render$1;var script = vue.defineComponent({
  name: "HeadlessTabSwitches",
  props: {
    ariaLabel: {
      type: [String, Number],
      default: "Tab list"
    },
    as: {
      type: String,
      default: "div"
    }
  },
  setup: function setup() {}
});function render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.as), {
    "aria-label": _ctx.ariaLabel,
    role: "tablist"
  }, {
    default: vue.withCtx(function () {
      return [vue.renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 8, ["aria-label"]);
}script.render = render;/* eslint-disable import/prefer-default-export */var components$1=/*#__PURE__*/Object.freeze({__proto__:null,HeadlessInput:script$l,InputField:script$k,TextareaField:script$j,SelectField:script$i,RadioField:script$h,CheckboxField:script$g,InputError:script$f,InputLabel:script$e,HeadlessForm:script$d,HeadlessAccordion:script$c,AccordionContent:script$a,AccordionHeader:script$9,AccordionToggle:script$8,HeadlessButton:script$7,HeadlessDialog:script$6,DialogContent:script$4,HeadlessTabs:script$3,HeadlessTab:script$2,HeadlessTabSwitch:script$1,HeadlessTabSwitches:script,DomObserver:script$5});var install = function installVueHeadlessUi(app) {
  Object.entries(components$1).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        componentName = _ref2[0],
        component = _ref2[1];

    app.component(componentName, component);
  });
};var components=/*#__PURE__*/Object.freeze({__proto__:null,'default':install,randomString:randomString,isMissingInjectable:isMissingInjectable,injectionKeys:injectionKeys,HeadlessInput:script$l,InputField:script$k,TextareaField:script$j,SelectField:script$i,RadioField:script$h,CheckboxField:script$g,InputError:script$f,InputLabel:script$e,HeadlessForm:script$d,HeadlessAccordion:script$c,AccordionContent:script$a,AccordionHeader:script$9,AccordionToggle:script$8,HeadlessButton:script$7,HeadlessDialog:script$6,DialogContent:script$4,HeadlessTabs:script$3,HeadlessTab:script$2,HeadlessTabSwitch:script$1,HeadlessTabSwitches:script,DomObserver:script$5});// only expose one global var, with component exports exposed as properties of
// that global var (eg. plugin.component)

Object.entries(components).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      componentName = _ref2[0],
      component = _ref2[1];

  if (componentName !== "default") {
    var key = componentName;
    install[key] = component;
  }
});module.exports=install;