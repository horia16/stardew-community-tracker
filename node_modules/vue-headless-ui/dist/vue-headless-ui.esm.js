import { computed, watch, defineComponent, ref, provide, openBlock, createBlock, resolveDynamicComponent, withCtx, renderSlot, inject, withDirectives, createElementBlock, vModelText, toDisplayString, createCommentVNode, Fragment, renderList, vModelSelect, onBeforeUnmount, vModelRadio, vModelCheckbox, createTextVNode, onMounted, watchEffect, resolveComponent, normalizeStyle, Teleport, mergeProps, onBeforeMount } from 'vue';
import { useField, useForm } from 'vee-validate';

/**
 * Create a random string
 */
function randomString(length = 30) {
  return [...Array(length)].map(() => Math.random().toString(36)[2]).join("");
}

/**
 * This function checks if any arguments are undefined and trows an error.
 */
function isMissingInjectable(...args) {
  for (let index = 0; index < args.length; index++) {
    const element = args[index];

    if (element === undefined) {
      throw new Error("Missing injectable variable, please make sure you are using the correct wrapper component.");
    }
  }
}

const ID$1 = Symbol("ID");
const INPUT_VALUE = Symbol("INPUT_VALUE");
const NAME = Symbol("NAME");
const ERROR_MESSAGE = Symbol("ERROR_MESSAGE");
const STATE = Symbol("STATE");
const VALIDATE = Symbol("VALIDATE");
const HANDLE_BLUR = Symbol("HANDLE_BLUR");
const META = Symbol("META");
const OPTIONS = Symbol("OPTIONS");
const INPUTS = Symbol("INPUTS");
var FORM = {
  ID: ID$1,
  INPUT_VALUE,
  OPTIONS,
  NAME,
  ERROR_MESSAGE,
  STATE,
  VALIDATE,
  HANDLE_BLUR,
  META,
  INPUTS
};

const ID = Symbol("ID");
const IS_OPEN$1 = Symbol("IS_OPEN");
var DIALOG = {
  ID,
  IS_OPEN: IS_OPEN$1
};

const IS_OPEN = Symbol("IS_OPEN");
const TOGGLE = Symbol("TOGGLE");
const COMPUTED_ID = Symbol("COMPUTED_ID");
const DELAY = Symbol("DELAY");
var ACCORDION = {
  IS_OPEN,
  TOGGLE,
  COMPUTED_ID,
  DELAY
};

const TAB_ARRAY = Symbol("TAB_ARRAY");
const SWITCH_ARRAY = Symbol("SWITCH_ARRAY");
const CURRENT_TAB = Symbol("CURRENT_TAB");
const SWITCH_TAB = Symbol("SWITCH_TAB");
var TABS = {
  TAB_ARRAY,
  SWITCH_ARRAY,
  CURRENT_TAB,
  SWITCH_TAB
};

const MATRIX = Symbol("MATRIX");
const UPDATE_DAY = Symbol("UPDATE_DAY");
const UPDATE_MONTH = Symbol("UPDATE_MONTH");
const UPDATE_YEAR = Symbol("UPDATE_YEAR");
const DATE_OBJECT = Symbol("DATE_OBJECT");
const START_SUNDAY = Symbol("START_SUNDAY");
const MODEL = Symbol("MODEL");
const LOCALE = Symbol("LOCALE");
var CALENDAR = {
  MATRIX,
  UPDATE_DAY,
  UPDATE_MONTH,
  UPDATE_YEAR,
  DATE_OBJECT,
  START_SUNDAY,
  MODEL,
  LOCALE
};

var injectionKeys = {
  FORM,
  ACCORDION,
  DIALOG,
  TABS,
  CALENDAR
};

var InputState;

(function (InputState) {
  InputState["Clear"] = "clear";
  InputState["Valid"] = "valid";
  InputState["Error"] = "error";
})(InputState || (InputState = {}));
/**
 * The minimal props required by an input type component
 */


const props$1 = {
  modelValue: {
    type: [String, Number, Boolean, Array, Object],
    default: null
  },
  options: {
    type: Array,
    default: null
  },
  id: {
    type: [String, Number],
    default: null
  },
  name: {
    type: [String, Number],
    default: null
  },
  rules: {
    type: [String, Function, Object],
    default: null
  },
  group: {
    type: Boolean,
    default: false
  },
  overrideState: {
    type: String,
    default: null
  }
};
/**
 * The minimal emits required by an input component
 */

const emits$1 = {
  blur: null,
  "update:modelValue": value => {
    if (value === undefined) {
      console.warn("Input context returned undefined value");
      return false;
    }

    return true;
  }
};
/**
 * A more complex version of the useField provided by vee-validate.
 * This takes care of a few extra things like auto id and name generation.
 */

function useFieldContext(props, context) {
  // Use the provided id otherwise generate a random one
  const inputId = props.id ? `${props.id}` : `input-${randomString()}`; // Use the provided name or generate one based on the id

  const inputName = props.name ? `${props.name}` : `${inputId}-name`; // Use validation only if we don't have a parent state

  const {
    errorMessage,
    value,
    meta,
    validate
  } = useField(inputName, props.rules);
  const inputValue = computed({
    get: () => props.modelValue,
    set: val => {
      // Emit our new value
      context.emit("update:modelValue", val);
    }
  });
  watch(inputValue, newVal => {
    // Update the vee-validate value
    value.value = newVal;
  });
  /**
   * The state of our input value
   */

  const state = computed(() => {
    if (props.overrideState != null) {
      return props.overrideState;
    }

    if (meta.touched && meta.validated) {
      if (meta.valid) {
        return InputState.Valid;
      }

      return InputState.Error;
    }

    return InputState.Clear;
  });
  /**
   * Handle the onblur event emitted by the input
   */

  async function handleBlur() {
    meta.touched = true;
    if (props.overrideState == null) await validate(); // Emit it further to the parent component

    context.emit("blur");
  } // If we already have a value upon entry


  if (props.modelValue) {
    // Update that in vee-validate
    value.value = props.modelValue; // Different scenario when the value is an array as we don't want to validate empty arrays upon creation

    if (Array.isArray(value.value)) {
      if (value.value.length > 0) {
        meta.touched = true;
        validate().catch(error => {
          console.warn(error);
        });
      }
    } else {
      meta.touched = true;
      validate().catch(error => {
        console.warn(error);
      });
    }
  }

  return {
    errorMessage,
    inputValue,
    inputName,
    inputId,
    meta,
    state,
    validate,
    handleBlur
  };
}
/**
 * Simple model wrapper for the vue v-model directive.
 */

function useModel(props, context) {
  return computed({
    get: () => props.modelValue,
    set: val => {
      context.emit("update:modelValue", val);
    }
  });
}

var script$l = defineComponent({
  name: "HeadlessInput",
  props: props$1,
  emits: emits$1,

  setup(props, context) {
    const {
      errorMessage,
      inputValue,
      inputName,
      inputId,
      state,
      validate,
      handleBlur,
      meta
    } = useFieldContext(props, context);
    const thing = [];
    const inputs = ref([]);
    provide(injectionKeys.FORM.ID, inputId);
    provide(injectionKeys.FORM.INPUT_VALUE, inputValue);
    provide(injectionKeys.FORM.NAME, inputName);
    provide(injectionKeys.FORM.ERROR_MESSAGE, errorMessage);
    provide(injectionKeys.FORM.STATE, state);
    provide(injectionKeys.FORM.VALIDATE, validate);
    provide(injectionKeys.FORM.HANDLE_BLUR, handleBlur);
    provide(injectionKeys.FORM.META, meta);
    provide(injectionKeys.FORM.OPTIONS, props.options);
    provide(injectionKeys.FORM.INPUTS, inputs);
    return {
      errorMessage,
      state,
      validate,
      handleBlur,
      meta,
      inputs,
      thing
    };
  }

});

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.group ? 'fieldset' : 'div'), {
    "data-input": "true"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      errorMessage: _ctx.errorMessage,
      handleBlur: _ctx.handleBlur,
      meta: _ctx.meta,
      state: _ctx.state,
      validate: _ctx.validate
    })]),
    _: 3
  });
}

script$l.render = render$l;

const emits = {
  blur: null
};
function setup$1() {
  const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
  const id = inject(injectionKeys.FORM.ID);
  const name = inject(injectionKeys.FORM.NAME);
  const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
  const state = inject(injectionKeys.FORM.STATE);
  const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
  isMissingInjectable(id, name, errorMessage, state, handleBlur);
  return {
    inputValue,
    id,
    name,
    handleBlur,
    errorMessage,
    state
  };
}

var script$k = defineComponent({
  name: "InputField",
  emits,
  setup: setup$1
});

const _hoisted_1$9 = ["id", "aria-describedby", "aria-invalid", "name"];
function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? `${_ctx.id}-error` : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, null, 40, _hoisted_1$9)), [[vModelText, _ctx.inputValue]]);
}

script$k.render = render$k;

var script$j = defineComponent({
  name: "TextareaField",
  emits,
  setup: setup$1
});

const _hoisted_1$8 = ["id", "aria-describedby", "aria-invalid"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("textarea", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? `${_ctx.id}-error` : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, null, 40, _hoisted_1$8)), [[vModelText, _ctx.inputValue]]);
}

script$j.render = render$j;

var script$i = defineComponent({
  name: "SelectField",
  props: {
    placeholder: {
      type: String,
      default: null
    },
    valueKey: {
      type: String,
      default: "value"
    },
    nameKey: {
      type: String,
      default: "name"
    }
  },
  emits,

  setup() {
    const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
    const id = inject(injectionKeys.FORM.ID);
    const name = inject(injectionKeys.FORM.NAME);
    const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
    const options = inject(injectionKeys.FORM.OPTIONS);
    if (!options) console.warn("Missing options. Please make sure are passing options to the headless input.");
    isMissingInjectable(id, inputValue, name, handleBlur, options);
    return {
      inputValue,
      id,
      handleBlur,
      options
    };
  }

});

const _hoisted_1$7 = ["id"];
const _hoisted_2$1 = {
  key: 0,
  value: null,
  disabled: "",
  hidden: "",
  selected: ""
};
const _hoisted_3 = ["value"];
function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("select", {
    id: _ctx.id,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.inputValue = $event),
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, [_ctx.placeholder ? (openBlock(), createElementBlock("option", _hoisted_2$1, toDisplayString(_ctx.placeholder), 1)) : createCommentVNode("", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
    return openBlock(), createElementBlock("option", {
      key: index,
      value: option[_ctx.valueKey]
    }, toDisplayString(option[_ctx.nameKey]), 9, _hoisted_3);
  }), 128))], 40, _hoisted_1$7)), [[vModelSelect, _ctx.inputValue]]);
}

script$i.render = render$i;

/**
 * Link a component to a given Ref Array, creating an unique id and the necessary events.
 * @param array
 */

function useArrayLink(array) {
  // Create a random id
  const id = ref(randomString()); // If we do not have that id push it to the array

  if (!(array !== null && array !== void 0 && array.value.find(x => x === id.value)) && id.value) {
    array === null || array === void 0 ? void 0 : array.value.push(id.value);
  } // Get the index of element


  const index = computed(() => {
    if (array) {
      const index = array.value.findIndex(x => x == id.value);

      if (index != null || index != undefined) {
        return index;
      }

      return -1;
    }

    return -1;
  }); // Make sure we remove the element from the array in case we unmount it

  onBeforeUnmount(() => {
    if (array) array.value = array.value.filter(x => x != id.value);
  });
  return {
    id,
    index
  };
}

const props = {
  value: {
    type: [String, Number, Object, Array],
    default: null
  }
};
function setup() {
  const inputValue = inject(injectionKeys.FORM.INPUT_VALUE);
  const id = inject(injectionKeys.FORM.ID);
  const name = inject(injectionKeys.FORM.NAME);
  const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
  const state = inject(injectionKeys.FORM.STATE);
  const meta = inject(injectionKeys.FORM.META, {
    touched: false,
    dirty: false,
    valid: false,
    validated: false,
    pending: false,
    initialValue: null
  });
  const handleBlur = inject(injectionKeys.FORM.HANDLE_BLUR);
  const inputs = inject(injectionKeys.FORM.INPUTS);
  isMissingInjectable(id, inputValue, name, errorMessage, state, handleBlur, inputs);
  const {
    id: inputId
  } = useArrayLink(inputs);
  return {
    inputValue,
    id,
    inputId,
    name,
    handleBlur,
    errorMessage,
    state,
    meta
  };
}

var script$h = defineComponent({
  name: "RadioField",
  props,
  emits,
  setup
});

const _hoisted_1$6 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? `${_ctx.id}-error` : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    value: _ctx.value,
    type: "radio",
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
    onChange: _cache[2] || (_cache[2] = $event => _ctx.meta.touched = true)
  }, null, 40, _hoisted_1$6)), [[vModelRadio, _ctx.inputValue]]);
}

script$h.render = render$h;

var script$g = defineComponent({
  name: "CheckboxField",
  props,
  emits,
  setup
});

const _hoisted_1$5 = ["id", "aria-describedby", "aria-invalid", "name", "value"];
function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    id: _ctx.inputId,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => _ctx.inputValue = $event),
    "aria-describedby": _ctx.errorMessage && _ctx.state === 'error' ? `${_ctx.id}-error` : undefined,
    "aria-invalid": _ctx.errorMessage && _ctx.state === 'error' ? true : undefined,
    name: _ctx.name,
    value: _ctx.value,
    type: "checkbox",
    onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
    onChange: _cache[2] || (_cache[2] = $event => _ctx.meta.touched = true)
  }, null, 40, _hoisted_1$5)), [[vModelCheckbox, _ctx.inputValue]]);
}

script$g.render = render$g;

var script$f = defineComponent({
  name: "InputError",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },

  setup() {
    const errorMessage = inject(injectionKeys.FORM.ERROR_MESSAGE);
    const state = inject(injectionKeys.FORM.STATE);
    const id = inject(injectionKeys.FORM.ID);
    isMissingInjectable(errorMessage, state, id);
    return {
      errorMessage,
      state,
      id
    };
  }

});

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.errorMessage && _ctx.state === 'error' ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: `${_ctx.id}-error`,
    "data-error": "true"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      errorMessage: _ctx.errorMessage
    }, () => [createTextVNode(toDisplayString(_ctx.errorMessage), 1)])]),
    _: 3
  }, 8, ["id"])) : createCommentVNode("", true);
}

script$f.render = render$f;

var script$e = defineComponent({
  name: "InputLabel",
  props: {
    text: {
      type: String,
      default: ""
    },
    legend: {
      type: Boolean,
      default: false
    },
    wrapper: {
      type: Boolean,
      default: false
    }
  },

  setup() {
    const inputId = inject(injectionKeys.FORM.ID);
    isMissingInjectable(inputId);
    return {
      inputId
    };
  }

});

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.legend ? 'legend' : 'label'), {
    for: _ctx.wrapper ? null : !_ctx.legend ? _ctx.inputId : null
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.text), 1)])]),
    _: 3
  }, 8, ["for"]);
}

script$e.render = render$e;

function useHeadlessForm(props, context) {
  const {
    handleSubmit,
    errors
  } = useForm();
  const triedToSubmit = ref(false);
  let sendErrorEvent = null;
  const onSubmit = handleSubmit(values => {
    sendErrorEvent = false;
    context.emit("submitted", values);
  });

  async function submit(e) {
    sendErrorEvent = true;
    triedToSubmit.value = true;
    await onSubmit(e);

    if (sendErrorEvent) {
      context.emit("failed", errors.value);
      setTimeout(() => {
        // Get the first error in the document
        let errorElement = document.querySelectorAll("[data-error]")[0];

        if (errorElement && props.scrollToError) {
          let parentElement = errorElement.parentElement;
          let inputElement = null; // Try and extract the input element

          while (parentElement !== null && inputElement === null) {
            if (parentElement.getAttribute("data-input")) {
              inputElement = parentElement;
            } else {
              parentElement = parentElement.parentElement;
            }
          }

          if (inputElement) {
            errorElement = inputElement;
          }

          errorElement.scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }
      }, 200);
    }
  }

  const errorCount = computed(() => !triedToSubmit.value ? 0 : Object.keys(errors.value).length);
  return {
    submit,
    errors,
    errorCount
  };
}

var script$d = defineComponent({
  name: "HeadlessForm",
  props: {
    scrollToError: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    submitted: null,
    failed: null
  },

  setup(props, context) {
    const {
      submit,
      errors,
      errorCount
    } = useHeadlessForm(props, context);
    return {
      submit,
      errors,
      errorCount
    };
  }

});

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    onSubmit: _cache[0] || (_cache[0] = (...args) => _ctx.submit && _ctx.submit(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    errorCount: _ctx.errorCount,
    errors: _ctx.errors,
    submit: _ctx.submit
  })], 32);
}

script$d.render = render$d;

var script$c = defineComponent({
  name: "HeadlessAccordion",
  props: {
    modelValue: {
      type: Boolean,
      default: null
    },
    self: {
      type: Boolean,
      default: false
    },
    openByDefault: {
      type: Boolean,
      default: false
    },
    animationDelay: {
      type: Number,
      default: 700
    },
    as: {
      type: String,
      default: "div"
    },
    id: {
      type: [String, Number],
      default: null
    }
  },
  emits: {
    "update:modelValue": null
  },

  setup(props, context) {
    const selfOpen = ref(!!props.openByDefault);
    const accordionId = computed(() => {
      return props.id ? `${props.id}` : `accordion-${randomString()}`;
    });
    const delay = computed(() => props.animationDelay); // If we are open by default and the v-model is set to false make it true
    //! This will still trigger the animation delay as of now because we are updating a proxy async and the initial state has been loaded already

    if (props.openByDefault == true && props.modelValue == false) {
      context.emit("update:modelValue", true);
    }

    const isOpen = computed({
      get: () => props.self ? selfOpen.value : props.modelValue,
      set: newValue => props.self ? selfOpen.value = newValue : context.emit("update:modelValue", newValue)
    });

    function toggle() {
      isOpen.value = !isOpen.value;
    }

    provide(injectionKeys.ACCORDION.DELAY, delay);
    provide(injectionKeys.ACCORDION.IS_OPEN, isOpen);
    provide(injectionKeys.ACCORDION.TOGGLE, toggle);
    provide(injectionKeys.ACCORDION.COMPUTED_ID, accordionId);
    return {};
  }

});

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.as), null, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  });
}

script$c.render = render$c;

var script$b = defineComponent({
  name: "AccordionContentWrapper",
  emits: {
    mounted: null
  },

  setup(props, {
    emit
  }) {
    const content = ref(null);
    onMounted(() => {
      if (content.value) {
        emit("mounted", content.value.scrollHeight);
      }
    });
    return {
      content
    };
  }

});

const _hoisted_1$4 = {
  ref: "content"
};
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [renderSlot(_ctx.$slots, "default")], 512);
}

script$b.render = render$b;

var script$a = defineComponent({
  components: {
    AccordionContentWrapper: script$b
  },
  name: "AccordionContent",

  setup() {
    const delay = inject(injectionKeys.ACCORDION.DELAY);
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(delay, isOpen, accordionId, toggle);
    const wrapper = ref(null);
    const visible = ref(!!(isOpen !== null && isOpen !== void 0 && isOpen.value));
    const height = ref(isOpen !== null && isOpen !== void 0 && isOpen.value ? null : 0);
    const overflow = ref("hidden"); // eslint-disable-next-line no-undef

    let zeroOutHeightTimeout = null; // eslint-disable-next-line no-undef

    let setInvisibleTimeout = null; // eslint-disable-next-line no-undef

    let setHeightAutoTimeout = null;

    function setHeightAuto() {
      height.value = null; // Set the overflow to auto when the accordion is fully expanded.

      overflow.value = "auto";
    }

    function setInvisible() {
      visible.value = false;
    }

    function setVisible() {
      visible.value = true;
    }

    function zeroOutHeight() {
      height.value = 0;
      overflow.value = "hidden"; // Remove the content completely from the dom after the animation has been completed.

      setInvisibleTimeout = setTimeout(setInvisible, delay === null || delay === void 0 ? void 0 : delay.value);
    }

    function contentMounted(scrollHeight) {
      height.value = scrollHeight; // Set the height to auto after the animation has been finished.

      setHeightAutoTimeout = setTimeout(setHeightAuto, delay === null || delay === void 0 ? void 0 : delay.value);
    }

    watchEffect(() => {
      // We are opening the accordion
      if (isOpen !== null && isOpen !== void 0 && isOpen.value) {
        var _wrapper$value;

        // If we have any timeout set for closing the accordion, i.e. opening it while the closing animation did not finish,  clear them
        if (setInvisibleTimeout) clearTimeout(setInvisibleTimeout);
        if (zeroOutHeightTimeout) clearTimeout(zeroOutHeightTimeout); // If the content wrapper is mounted already, get the height

        if ((_wrapper$value = wrapper.value) !== null && _wrapper$value !== void 0 && _wrapper$value.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        } // Set the visibility of the content to true


        setVisible();
      } else {
        var _wrapper$value2;

        // If we have any timeout set for opening the accordion, clear it
        if (setHeightAutoTimeout) clearTimeout(setHeightAutoTimeout); // If we have a wrapper set from height auto to the height of the wrapper so we can get a nice transition

        if ((_wrapper$value2 = wrapper.value) !== null && _wrapper$value2 !== void 0 && _wrapper$value2.$el) {
          height.value = wrapper.value.$el.scrollHeight;
        } // Set the height to 0 after 20 ms so the css engine will play the transition


        zeroOutHeightTimeout = setTimeout(zeroOutHeight, 20);
      }
    });
    return {
      isOpen,
      toggle,
      wrapper,
      height,
      overflow,
      visible,
      delay,
      accordionId,
      contentMounted
    };
  }

});

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_accordion_content_wrapper = resolveComponent("accordion-content-wrapper");

  return _ctx.visible ? (openBlock(), createBlock(_component_accordion_content_wrapper, {
    key: 0,
    id: _ctx.accordionId,
    ref: "wrapper",
    "aria-labelledby": `${_ctx.accordionId}_toggle`,
    style: normalizeStyle({
      height: _ctx.height != null ? `${_ctx.height}px` : 'auto',
      overflow: _ctx.overflow,
      transition: `height ${_ctx.delay}ms`
    }),
    role: "region",
    onMounted: _ctx.contentMounted
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      open: _ctx.isOpen,
      toggle: _ctx.toggle
    })]),
    _: 3
  }, 8, ["id", "aria-labelledby", "style", "onMounted"])) : createCommentVNode("", true);
}

script$a.render = render$a;

var script$9 = defineComponent({
  name: "AccordionHeader",

  setup() {
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen,
      toggle,
      accordionId
    };
  }

});

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen,
    toggle: _ctx.toggle
  })]);
}

script$9.render = render$9;

var script$8 = defineComponent({
  name: "AccordionToggle",

  setup() {
    const isOpen = inject(injectionKeys.ACCORDION.IS_OPEN);
    const accordionId = inject(injectionKeys.ACCORDION.COMPUTED_ID);
    const toggle = inject(injectionKeys.ACCORDION.TOGGLE);
    isMissingInjectable(isOpen, accordionId, toggle);
    return {
      isOpen,
      toggle,
      accordionId
    };
  }

});

const _hoisted_1$3 = ["id", "aria-controls", "aria-expanded"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    id: `${_ctx.accordionId}_toggle`,
    "aria-controls": _ctx.accordionId,
    "aria-expanded": _ctx.isOpen,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggle && _ctx.toggle(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    accordionId: _ctx.accordionId,
    isOpen: _ctx.isOpen
  })], 8, _hoisted_1$3);
}

script$8.render = render$8;

var script$7 = defineComponent({
  name: "HeadlessButton",
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  }
});

const _hoisted_1$2 = ["disabled", "aria-busy", "aria-live"];
const _hoisted_2 = {
  key: 0
};
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    disabled: _ctx.disabled || _ctx.loading,
    "aria-busy": _ctx.loading ? true : undefined,
    "aria-live": _ctx.loading ? 'polite' : undefined
  }, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.label), 1)]), _ctx.loading ? (openBlock(), createElementBlock("span", _hoisted_2, [renderSlot(_ctx.$slots, "loading")])) : createCommentVNode("", true)], 8, _hoisted_1$2);
}

script$7.render = render$7;

const dialogs = ref([]);
function useDialogModel(props, context) {
  /**
   * Random dialog id.
   */
  const id = randomString();
  const value = computed({
    get: () => props.modelValue,
    set: newVal => {
      if (newVal) {
        document.body.style.overflow = "hidden";
      }

      context.emit("update:modelValue", newVal);
    }
  });
  let activeElement = null;
  watch(value, () => {
    if (value.value) {
      // We are opening the dialog so push it to the dialogs array
      dialogs.value.push(id); // Make sure we hide the scroll on the body

      document.body.style.overflow = "hidden"; // When we open the modal keep the element that we were focused on in memory

      if (document.activeElement) {
        activeElement = document.activeElement;
      }
    } else {
      // Closing the dialog so remove it from the array. It should always be on top for nested dialogs.
      dialogs.value = dialogs.value.filter(x => x != id); // If we have note left remove the overflow from the body

      if (dialogs.value.length == 0) {
        document.body.style.overflow = "";
      } // Focus back on the element that we were focused on prior to opening the modal


      if (activeElement) {
        activeElement.focus();
      }
    }
  });
  return {
    value,
    id
  };
}

var script$6 = defineComponent({
  name: "HeadlessDialog",
  props: {
    zIndex: {
      type: Number,
      default: 100
    },
    modelValue: {
      type: Boolean,
      default: null
    },
    fullScreen: {
      type: Boolean,
      default: false
    }
  },
  inheritAttrs: false,

  setup(props, context) {
    const height = ref(window.innerHeight);
    const {
      value: isOpen,
      id
    } = useDialogModel(props, context);
    provide(injectionKeys.DIALOG.ID, id);
    provide(injectionKeys.DIALOG.IS_OPEN, isOpen);

    function updateHeight() {
      height.value = window.innerHeight;
    }

    onMounted(() => {
      window.addEventListener("resize", updateHeight);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", updateHeight);
    });
    return {
      height,
      isOpen
    };
  }

});

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, {
    to: "body"
  }, [_ctx.isOpen ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    style: !_ctx.fullScreen ? {
      top: 0,
      left: 0,
      position: 'fixed',
      width: '100vw',
      height: `${_ctx.height}px`,
      zIndex: _ctx.zIndex
    } : {}
  }, _ctx.$attrs), [renderSlot(_ctx.$slots, "default")], 16)) : createCommentVNode("", true)]);
}

script$6.render = render$6;

var script$5 = defineComponent({
  name: "DomObserver",
  props: {
    config: {
      type: Object,
      default: () => {
        return {
          attributes: true,
          childList: true,
          subtree: true
        };
      }
    }
  },
  emits: {
    updated: null,
    mounted: null
  },

  setup(props, context) {
    const content = ref(null);

    function callback() {
      context.emit("updated", content.value);
    }

    const observer = new MutationObserver(callback);
    onMounted(() => {
      if (content.value) {
        observer.observe(content.value, props.config);
        context.emit("mounted", content.value);
      }
    });
    onBeforeMount(() => {
      observer.disconnect();
    });
    return {
      content
    };
  }

});

const _hoisted_1$1 = {
  ref: "content"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [renderSlot(_ctx.$slots, "default")], 512);
}

script$5.render = render$5;

var script$4 = defineComponent({
  components: {
    DomObserver: script$5
  },
  name: "DialogContent",

  setup() {
    const isOpen = inject(injectionKeys.DIALOG.IS_OPEN);
    const id = inject(injectionKeys.DIALOG.ID);
    isMissingInjectable(isOpen, id);
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    let focusableContent = null;

    function reloadDomArray(content) {
      focusableContent = content === null || content === void 0 ? void 0 : content.querySelectorAll(focusableElements); // If we are already focused on an element form this array we should not not reset the focus.

      if (focusableContent) {
        let shouldResetFocus = true;

        for (let index = 0; index < focusableContent.length; index++) {
          const element = focusableContent[index];

          if (document.activeElement == element) {
            shouldResetFocus = false;
            break;
          }
        }

        if (focusableContent[0] && shouldResetFocus) {
          // Focus on the first available element
          focusableContent[0].focus();
        }
      }
    }

    function onKeyDown(event) {
      // If the last active dialog is this
      if (dialogs.value[dialogs.value.length - 1] == id) {
        if (isOpen !== null && isOpen !== void 0 && isOpen.value && focusableContent) {
          const isTabPressed = event.key == "Tab";

          if (event.key == "Escape") {
            isOpen.value = false;
          }

          if (!isTabPressed) {
            return;
          }

          if (event.shiftKey) {
            if (document.activeElement === focusableContent[0]) {
              focusableContent[focusableContent.length - 1].focus();
              event.preventDefault();
            }
          } else {
            if (document.activeElement === focusableContent[focusableContent.length - 1]) {
              focusableContent[0].focus();
              event.preventDefault();
            }
          }
        }
      }
    }

    onMounted(() => {
      document.addEventListener("keydown", onKeyDown);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("keydown", onKeyDown);
    });
    return {
      reloadDomArray,
      id
    };
  }

});

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_dom_observer = resolveComponent("dom-observer");

  return openBlock(), createBlock(_component_dom_observer, {
    id: _ctx.id,
    "aria-modal": "true",
    onMounted: _ctx.reloadDomArray,
    onUpdated: _ctx.reloadDomArray
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["id", "onMounted", "onUpdated"]);
}

script$4.render = render$4;

var script$3 = defineComponent({
  name: "HeadlessTabs",
  props: {
    modelValue: {
      type: Number,
      default: null
    }
  },

  setup(props, context) {
    const currentTab = useModel(props, context);
    const tabs = ref([]);
    const switches = ref([]);

    function switchTab(index) {
      currentTab.value = index;
    }

    provide(injectionKeys.TABS.CURRENT_TAB, currentTab);
    provide(injectionKeys.TABS.TAB_ARRAY, tabs);
    provide(injectionKeys.TABS.SWITCH_ARRAY, switches);
    provide(injectionKeys.TABS.SWITCH_TAB, switchTab);
    return {
      currentTab,
      switchTab
    };
  }

});

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    switchTab: _ctx.switchTab
  })]);
}

script$3.render = render$3;

var script$2 = defineComponent({
  name: "HeadlessTab",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },

  setup() {
    const tabs = inject(injectionKeys.TABS.TAB_ARRAY);
    const switches = inject(injectionKeys.TABS.SWITCH_ARRAY, ref([]));
    const currentTab = inject(injectionKeys.TABS.CURRENT_TAB);
    const switchTab = inject(injectionKeys.TABS.SWITCH_TAB);
    isMissingInjectable(tabs, switches, currentTab, switchTab);
    const {
      id,
      index
    } = useArrayLink(tabs);
    return {
      currentTab,
      index,
      switchTab,
      id,
      switches
    };
  }

});

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.index === _ctx.currentTab ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    key: 0,
    id: _ctx.id,
    "aria-labelledby": _ctx.switches[_ctx.index],
    role: "tabpanel"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
      currentTab: _ctx.currentTab,
      switchTab: _ctx.switchTab,
      tabIndex: _ctx.index
    })]),
    _: 3
  }, 8, ["id", "aria-labelledby"])) : createCommentVNode("", true);
}

script$2.render = render$2;

var script$1 = defineComponent({
  name: "HeadlessTabSwitch",

  setup() {
    const switchButton = ref(null);
    const switches = inject(injectionKeys.TABS.SWITCH_ARRAY);
    const tabs = inject(injectionKeys.TABS.TAB_ARRAY, ref([]));
    const currentTab = inject(injectionKeys.TABS.CURRENT_TAB);
    const switchTab = inject(injectionKeys.TABS.SWITCH_TAB, () => {});
    isMissingInjectable(switches, currentTab);

    function onKeyDown(e) {
      if (currentTab && switches && switchTab) {
        switch (e.key) {
          case "ArrowRight":
            if (currentTab.value + 1 <= switches.value.length - 1) {
              switchTab(currentTab.value + 1);
            } else {
              switchTab(0);
            }

            break;

          case "ArrowLeft":
            if (currentTab.value - 1 >= 0) {
              switchTab(currentTab.value - 1);
            } else {
              switchTab(switches.value.length - 1);
            }

            break;

          case "Home":
            switchTab(0);
            break;

          case "End":
            switchTab(switches.value.length - 1);
            break;
        }
      }
    }

    const {
      id,
      index
    } = useArrayLink(switches);
    watchEffect(() => {
      if ((currentTab === null || currentTab === void 0 ? void 0 : currentTab.value) == index.value) {
        var _document$activeEleme;

        // Get the focus only if we move from another tab button
        if (switchButton.value && ((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.getAttribute("role")) == "tab") {
          switchButton.value.focus();
        }
      }
    });
    return {
      currentTab,
      index,
      id,
      switchTab,
      onKeyDown,
      switchButton,
      tabs
    };
  }

});

const _hoisted_1 = ["id", "aria-controls", "aria-selected", "tabindex"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    id: _ctx.id,
    ref: "switchButton",
    "aria-controls": _ctx.tabs[_ctx.index],
    "aria-selected": _ctx.index === _ctx.currentTab,
    tabindex: _ctx.index !== _ctx.currentTab ? -1 : undefined,
    role: "tab",
    type: "button",
    onClick: _cache[0] || (_cache[0] = $event => _ctx.switchTab(_ctx.index)),
    onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.onKeyDown && _ctx.onKeyDown(...args))
  }, [renderSlot(_ctx.$slots, "default", {
    currentTab: _ctx.currentTab,
    index: _ctx.index,
    switchTab: _ctx.switchTab
  })], 40, _hoisted_1);
}

script$1.render = render$1;

var script = defineComponent({
  name: "HeadlessTabSwitches",
  props: {
    ariaLabel: {
      type: [String, Number],
      default: "Tab list"
    },
    as: {
      type: String,
      default: "div"
    }
  },

  setup() {}

});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.as), {
    "aria-label": _ctx.ariaLabel,
    role: "tablist"
  }, {
    default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
    _: 3
  }, 8, ["aria-label"]);
}

script.render = render;

/* eslint-disable import/prefer-default-export */

var components = /*#__PURE__*/Object.freeze({
  __proto__: null,
  HeadlessInput: script$l,
  InputField: script$k,
  TextareaField: script$j,
  SelectField: script$i,
  RadioField: script$h,
  CheckboxField: script$g,
  InputError: script$f,
  InputLabel: script$e,
  HeadlessForm: script$d,
  HeadlessAccordion: script$c,
  AccordionContent: script$a,
  AccordionHeader: script$9,
  AccordionToggle: script$8,
  HeadlessButton: script$7,
  HeadlessDialog: script$6,
  DialogContent: script$4,
  HeadlessTabs: script$3,
  HeadlessTab: script$2,
  HeadlessTabSwitch: script$1,
  HeadlessTabSwitches: script,
  DomObserver: script$5
});

// Import vue components

const install = function installVueHeadlessUi(app) {
  Object.entries(components).forEach(([componentName, component]) => {
    app.component(componentName, component);
  });
};

export { script$a as AccordionContent, script$9 as AccordionHeader, script$8 as AccordionToggle, script$g as CheckboxField, script$4 as DialogContent, script$5 as DomObserver, script$c as HeadlessAccordion, script$7 as HeadlessButton, script$6 as HeadlessDialog, script$d as HeadlessForm, script$l as HeadlessInput, script$2 as HeadlessTab, script$1 as HeadlessTabSwitch, script as HeadlessTabSwitches, script$3 as HeadlessTabs, script$f as InputError, script$k as InputField, script$e as InputLabel, script$h as RadioField, script$i as SelectField, script$j as TextareaField, install as default, injectionKeys, isMissingInjectable, randomString };
